/**
 * @file Scroll gradient.
 * @copyright IBM Security 2019 - 2021
 */

import classnames from 'classnames';
import PropTypes from 'prop-types';
import React, { Component } from 'react';

import { throttle } from 'throttle-debounce';

import { getComponentNamespace } from '../../globals/namespace';
import { isClient } from '../../globals/utils/capabilities';

export const namespace = getComponentNamespace('scroll-gradient');

const scrollDirection = { X: 'X', Y: 'Y' };

class ScrollGradient extends Component {
  static propTypes = {
    /** @type {string} Scroll area children */
    children: PropTypes.oneOfType([
      PropTypes.arrayOf(PropTypes.node),
      PropTypes.node,
    ]),

    /** @type {string} Optional classname */
    className: PropTypes.string,

    /** @type {string} Fade out color. Any valid CSS color value works */
    color: PropTypes.string.isRequired,

    /** @type {string} Scroll direction */
    direction: PropTypes.oneOf(['X', 'Y']),

    /** @type {(element: HTMLElement) => {}} Optional function to get reference to scrollable DOM element */
    getScrollElementRef: PropTypes.func,

    /** @type {boolean} Set to true if you want to hide gradient on the start side (top or left) of scrollable element. */
    hideStartGradient: PropTypes.bool,

    /** @type {Function} Optional scroll handler */
    onScroll: PropTypes.func,

    /** @type {string} Optional classname for scroll element. */
    scrollElementClassName: PropTypes.string,
  };

  static defaultProps = {
    className: undefined,
    children: undefined,
    scrollElementClassName: undefined,
    direction: scrollDirection.Y,
    hideStartGradient: false,
    onScroll: () => {},
    getScrollElementRef: () => {},
  };

  /**
   * Gets the scroll state position of a given element.
   * @param {HTMLElement} element The element to get scroll state of.
   * @param {string} scrollDirection The scroll direction to get the state of.
   * @returns {string} State of scroll position.
   * @static
   */
  static getScrollState = (element, scrollDirection) => {
    switch (scrollDirection) {
      case ScrollGradient.ScrollDirection.X: {
        if (element.scrollWidth === element.clientWidth) {
          return ScrollGradient.ScrollStates.NONE;
        }
        if (element.scrollLeft === 0) {
          return ScrollGradient.ScrollStates.INITIAL;
        }
        if (element.scrollLeft + element.clientWidth === element.scrollWidth) {
          return ScrollGradient.ScrollStates.END;
        }
        return ScrollGradient.ScrollStates.STARTED;
      }

      case ScrollGradient.ScrollDirection.Y:
      default: {
        if (element.scrollHeight === element.clientHeight) {
          return ScrollGradient.ScrollStates.NONE;
        }
        if (element.scrollTop === 0) {
          return ScrollGradient.ScrollStates.INITIAL;
        }
        if (element.scrollTop + element.clientHeight === element.scrollHeight) {
          return ScrollGradient.ScrollStates.END;
        }
        return ScrollGradient.ScrollStates.STARTED;
      }
    }
  };

  state = {
    position: ScrollGradient.ScrollStates.NONE,
  };

  componentDidMount() {
    if (this.scrollContainer) {
      this.updateScrollState();
    }

    if (isClient()) {
      // https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver
      this.resizeObserver = new ResizeObserver(this.updateHandler);

      this.resizeObserver.observe(this.scrollContainer);
    }
  }

  componentDidUpdate() {
    if (
      this.state.position !==
      ScrollGradient.getScrollState(this.scrollContainer, this.props.direction)
    ) {
      this.updateScrollState();
    }
  }

  componentWillUnmount() {
    this.resizeObserver.disconnect();
  }

  /**
   * Saves references of scroll DOM element.
   * @param {HTMLElement} element Scroll DOM element.
   */
  setRefs = (element) => {
    this.scrollContainer = element;
    this.props.getScrollElementRef(element);
  };

  /** @enum Possible scroll directions  */
  static ScrollDirection = scrollDirection;

  /** @enum Scroll position states */
  static ScrollStates = {
    // No scrolling required because content fits within container.
    NONE: 'NONE',

    // Scroll position is a the start of the scrollable content.
    INITIAL: 'INITIAL',

    // Scroll position is neither at start or end of scrollable content.
    STARTED: 'STARTED',

    // Scroll position is a the end of the scrollable content.
    END: 'END',
  };

  /**
   * Handles scrolling event of scroll element.
   * @param {Event} event Scroll event generated by user.
   */
  scrollHandler = (event) => {
    this.props.onScroll(event);
    this.updateHandler();
  };

  /**
   * Updates the scroll state of component.
   */
  updateScrollState = () =>
    this.setState({
      position: ScrollGradient.getScrollState(
        this.scrollContainer,
        this.props.direction
      ),
    });

  /**
   * @type {Function} Debounces the execution of scroll state update.
   */
  updateHandler = throttle(150, this.updateScrollState);

  /** @type {HTMLElement} Scrollable element reference. */
  scrollContainer = null;

  render() {
    const {
      className,
      children,
      direction,
      color,
      onScroll: _, // Throw away.
      scrollElementClassName,
      getScrollElementRef: __, // Throw away.
      hideStartGradient,
      ...other
    } = this.props;
    const { position } = this.state;
    const gradientRotation =
      direction === ScrollGradient.ScrollDirection.X ? -90 : 0;

    return (
      <div
        className={classnames(
          namespace,
          `${namespace}--${position.toLowerCase()}`,
          `${namespace}--${direction.toLowerCase()}`,
          className
        )}
        role="presentation"
        {...other}
      >
        {!hideStartGradient && (
          <div
            className={`${namespace}__before`}
            style={{
              backgroundImage: `linear-gradient(${gradientRotation}deg, rgba(0,0,0,0), ${color} 90%)`,
            }}
            role="presentation"
            aria-hidden
          />
        )}
        <div
          onScroll={this.scrollHandler}
          ref={this.setRefs}
          className={classnames(
            `${namespace}__content`,
            scrollElementClassName
          )}
        >
          {children}
        </div>
        <div
          className={`${namespace}__after`}
          style={{
            backgroundImage: `linear-gradient(${gradientRotation}deg, ${color} 10%, rgba(0,0,0,0))`,
          }}
          role="presentation"
          aria-hidden
        />
      </div>
    );
  }
}

export default ScrollGradient;
