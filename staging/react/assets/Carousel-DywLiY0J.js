import{e as a,c as $,p as O,P as s,r,u as X}from"./iframe-DoONWhft.js";import{g as B}from"./devtools-Bope-Kcp.js";import{u as F}from"./useIsomorphicEffect-DNoZHH_8.js";const Y=`${O.prefix}--carousel__item`,M="CarouselItem",b=a.forwardRef(({children:y,className:v,...h},w)=>a.createElement("div",{...h,className:$(Y,v),...B(M),ref:w},y));b.displayName=M;b.propTypes={children:s.node.isRequired,className:s.string};b.__docgenInfo={description:"TODO: A description of the component.",methods:[],displayName:"CarouselItem",props:{children:{required:!0,tsType:{name:"ReactNode"},description:"Provide the contents of the CarouselItem.",type:{name:"node"}},className:{required:!1,tsType:{name:"string"},description:"Provide an optional class to be applied to the containing node.",type:{name:"string"}}}};const m=`${O.prefix}--carousel`,j="Carousel",S={disableArrowScroll:!1,onScroll:()=>{},onChangeIsScrollable:()=>{}},k=a.forwardRef((y,v)=>{const{children:h,className:w,disableArrowScroll:I=S.disableArrowScroll,fadedEdgeColor:c,onChangeIsScrollable:q=S.onChangeIsScrollable,onScroll:T=S.onScroll,isScrollMode:z=!1,...H}=y,x=r.useRef(null),l=r.useRef(null),u=r.useRef(null),f=r.useRef(null),p=r.useRef(Array(a.Children.count(h)).fill(r.useRef(null))),E=typeof c=="object"?c?.left:c,C=typeof c=="object"?c?.right:c,N=X(),i=r.useCallback(()=>{if(!l.current)return;const t=l.current?.clientWidth,e=parseInt(`${l.current?.scrollLeft}`,10),n=l.current?.scrollWidth,o=n-t,d=parseFloat((e/o).toFixed(2))||0;q(n>t),T(d)},[q,T]),L=r.useCallback((t,e)=>{const n=e.left>=t.left,o=e.right<=t.right;return n&&o},[]),A=r.useCallback(()=>{const t=l?.current?.getBoundingClientRect();return p.current.filter(n=>L(t,n.getBoundingClientRect()))},[L]),g=r.useCallback(()=>{const t=l?.current?.getBoundingClientRect(),e=A().map(o=>o.getBoundingClientRect()),n=e.reduce((o,d)=>o+d.width,0);return{containerRect:t,elementRectsInView:e,visibleWidth:n}},[A]),P=r.useCallback(()=>{if(!l.current)return;const{containerRect:t,visibleWidth:e}=g(),n=e>0?e:t?.width;l.current.scrollLeft+=n},[g]),_=r.useCallback(()=>{if(!l.current)return;const{containerRect:t,elementRectsInView:e,visibleWidth:n}=g(),o=n>0?n-e[0].left:(t?.width??0)+(t?.left??0);l.current.scrollLeft-=o},[g]),V=r.useCallback(()=>{l.current&&(l.current.scrollLeft=0,i())},[i]),D=r.useCallback(t=>{W(t),p.current[t]?.scrollIntoView()},[]),K=t=>{const e=`:not(.${N}--visually-hidden,.${N}--btn--disabled,[aria-hidden="true"],[disabled])`,n=`button${e}`,o=`input${e}`,d=`select${e}`,R=`textarea${e}`,Q=`[href]${e}`,G=`a${e}`,J=`[tabindex="0"]${e}`,U=`${n},${Q},${G},${o},${d},${R},${J}`;return t?.querySelectorAll(`${U}`)??[]},W=t=>{!z&&p.current?.forEach((e,n)=>{const o=n===t;e?.setAttribute("aria-hidden",String(!o)),K(e).forEach(R=>{R.tabIndex=o?0:-1})})};return r.useEffect(()=>{setTimeout(()=>{W(0),i()},0)},[]),r.useEffect(()=>{const t=()=>{l.current&&(l.current.scrollLeft=0,i())};return window.addEventListener("resize",t),()=>window.removeEventListener("resize",t)},[i]),r.useEffect(()=>{const t=()=>{i()},e=l.current;return e?.addEventListener("scrollend",t),()=>e?.removeEventListener("scrollend",t)},[i]),r.useEffect(()=>{function t(n){n.shiftKey&&(n.stopPropagation(),n.preventDefault(),n.cancelBubble=!1)}const e=l.current;if(e)return e.addEventListener("wheel",t,{passive:!1}),()=>{e.removeEventListener("wheel",t)}},[]),r.useEffect(()=>{function t(n){const{key:o}=n;(o==="ArrowLeft"||o==="ArrowRight")&&I&&(n.stopPropagation(),n.preventDefault(),n.cancelBubble=!1)}const e=x.current;if(e)return e.addEventListener("keydown",t),()=>e.removeEventListener("keydown",t)},[I]),r.useImperativeHandle(v,()=>({scrollNext(){P()},scrollPrev(){_()},scrollReset(){V()},scrollToView(t){D(t)}}),[P,_,V,D]),F(()=>{u?.current&&u.current.style&&(u.current.style.background=`linear-gradient(90deg, ${E}, transparent)`)},[u,E]),F(()=>{f?.current&&f.current.style&&(f.current.style.background=`linear-gradient(270deg, ${C}, transparent)`)},[f,C]),a.createElement("div",{...H,tabIndex:-1,className:$(m,w),ref:x,...B(j)},a.createElement("div",{className:$(`${m}__elements-container`)},a.createElement("div",{className:`${m}__elements`,ref:l},a.Children.map(h,(t,e)=>a.createElement(b,{key:e,ref:n=>{p.current[e]=n}},t))),E&&a.createElement("div",{ref:u,className:`${m}__elements-container--scrolled`}),C&&a.createElement("div",{ref:f,className:`${m}__elements-container--scroll-max`})))});k.displayName=j;k.propTypes={children:s.node.isRequired,className:s.string,disableArrowScroll:s.bool,fadedEdgeColor:s.oneOfType([s.string,s.shape({left:s.string,right:s.string})]),isScrollMode:s.bool,onChangeIsScrollable:s.func,onScroll:s.func};k.__docgenInfo={description:`The Carousel acts as a scaffold for other Onboarding content.

This component is not intended for general use.

Expected scrolling behavior.
1. Scroll the maximum number of visible items at a time.
2. The left-most item should always be left-aligned in the viewport.

Exception.
1. After scrolling to the last (right-most) item,
     if some of its content remains hidden,
     then nudge it to the right until it is right-aligned.
2. From the right-aligned position, when scrolling left,
     the left-most item should again be left-aligned.`,methods:[{name:"scrollNext",docblock:null,modifiers:[],params:[],returns:null},{name:"scrollPrev",docblock:null,modifiers:[],params:[],returns:null},{name:"scrollReset",docblock:null,modifiers:[],params:[],returns:null},{name:"scrollToView",docblock:null,modifiers:[],params:[{name:"itemNumber",optional:!1,type:null}],returns:null}],displayName:"Carousel",props:{children:{required:!0,tsType:{name:"ReactNode"},description:"Provide the contents of the Carousel.",type:{name:"node"}},className:{required:!1,tsType:{name:"string"},description:"Provide an optional class to be applied to the containing node.",type:{name:"string"}},disableArrowScroll:{required:!1,tsType:{name:"boolean"},description:`Disables the ability of the Carousel to scroll
use a keyboard's left and right arrow keys.`,type:{name:"bool"}},fadedEdgeColor:{required:!1,tsType:{name:"union",raw:"string | { left: string; right: string }",elements:[{name:"string"},{name:"signature",type:"object",raw:"{ left: string; right: string }",signature:{properties:[{key:"left",value:{name:"string",required:!0}},{key:"right",value:{name:"string",required:!0}}]}}]},description:"Enables the edges of the component to have faded styling.\n\nPass a single string (`$color`) to specify the same color for left and right.\n\nOr pass an object (`{ left: $color1, right: $color2 }`) to specify different colors.",type:{name:"union",value:[{name:"string"},{name:"shape",value:{left:{name:"string",required:!1},right:{name:"string",required:!1}}}]}},onChangeIsScrollable:{required:!1,tsType:{name:"signature",type:"function",raw:"(isScrollable: boolean) => void",signature:{arguments:[{type:{name:"boolean"},name:"isScrollable"}],return:{name:"void"}}},description:"An optional callback function that returns `true`\nwhen the carousel has enough content to be scrollable,\nand `false` when there is not enough content.",type:{name:"func"}},onScroll:{required:!1,tsType:{name:"signature",type:"function",raw:"(scrollPercent: number) => void",signature:{arguments:[{type:{name:"number"},name:"scrollPercent"}],return:{name:"void"}}},description:`An optional callback function that returns the scroll position as
a value between 0 and 1.`,type:{name:"func"}},isScrollMode:{required:!1,tsType:{name:"boolean"},description:`enable scroll mode when only scroll functionality is required, more than one items will be visible at a time
when isScrollMode is false, component behaves like a carousal and on item will be active at a time
and other items will be hidden and inactive.`,type:{name:"bool"}}}};export{k as C};
