import{j as t,aA as R,r as i,e as n,B as k}from"./iframe-Bn5s87s4.js";import{C as V}from"./Checkbox-CJXd6mx6.js";import{F as W}from"./FormLabel-D6OLnxKu.js";import{I as K}from"./InlineLoading-D_UBaimj.js";import{L as _}from"./Link-DzeRYl9b.js";import{s as E,M as z}from"./codePreviewer-DNSNcE0k.js";import{T as M}from"./Notification-CtthtuHR.js";import{T as P}from"./TextInput-DKAT8fdL.js";import{w as T}from"./wait-CTNFjQS8.js";import{useMDXComponents as X}from"./index-DEJj3RFA.js";import{d as A}from"./bucket-10-BuKWHJFA.js";import{T as Q}from"./bucket-18-CjQdBR0X.js";import"./preload-helper-PPVm8Dsz.js";import"./Text-DPxQhslY.js";import"./index-C9jChmFj.js";import"./utils-DQejB-zS.js";import"./bucket-19-C9HfQtRN.js";import"./bucket-6-4QPuED9F.js";import"./AccordionItem-O5m-Fw82.js";import"./SkeletonText-CDcl1bge.js";import"./AspectRatio-Cq83aMrl.js";import"./BreadcrumbItem-D-vJ8KBr.js";import"./bucket-13-Dndxk466.js";import"./ButtonSet-CXQgRZeZ.js";import"./index-wuqyTjN_.js";import"./inheritsLoose-DHKJTbHM.js";import"./FormContext-C5gYs1Iz.js";import"./MultiSelect-bJRW7UcD.js";import"./mergeRefs-BZpmU3mx.js";import"./defaultItemToString-zSItMTD_.js";import"./useAttachedMenu-DhlZrLf-.js";import"./ComposedModal-0BWEXzM1.js";import"./index-D9UDgIUg.js";import"./LayerContext-BihYEre2.js";import"./clamp--00YEiB8.js";import"./requiredIfGivenPropIsTruthy-C6rAip-Q.js";import"./wrapFocus-p8CeO0Q6.js";import"./DataTable-SojopVzL.js";import"./TableRow-CM86TcFN.js";import"./wrapComponent-CnV40MCj.js";import"./bucket-0-Ba9itZYk.js";import"./bucket-1-0FbbcnG1.js";import"./TableToolbar-CvvJsKwN.js";import"./index-DlCtKpC6.js";import"./TableSelectRow-B808eWj6.js";import"./RadioButton-BvWHKHci.js";import"./useNormalizedInputProps-jypMYg7X.js";import"./OverflowMenuItem-BnHmJgeq.js";import"./TableToolbarSearch-CSL-UoeE.js";import"./Search-T7tqaylz.js";import"./bucket-15-CS3Y4Mgh.js";import"./index-DViADvk5.js";import"./useOutsideClick-f2_z0C-o.js";import"./DatePicker-DtfW-GAe.js";import"./bucket-2-S1beR83x.js";import"./documentLang-E105Y72C.js";import"./Dropdown-CMaceGXW.js";import"./Form-Cpb4YMSC.js";import"./FormGroup-D7ED0Srn.js";import"./Grid-27E2mo_3.js";import"./Row-CxE5eR4j.js";import"./Column-CHOMlM5E.js";import"./Icon.Skeleton-JtbM36CA.js";import"./ListItem-CslmXD90.js";import"./MenuItem-CrClIjlz.js";import"./useControllableState-CDFtAfEZ.js";import"./index-BRKV1vw1.js";import"./NumberInput-Ce4px8fu.js";import"./bucket-17-CLqhTMCi.js";import"./useMatchMedia-CLAFCcru.js";import"./DefinitionTooltip-CwHpCgPH.js";import"./overflowHandler-6nRVSJRW.js";import"./Tag-sQsnyISB.js";import"./OperationalTag-B-TUI2Gy.js";import"./Pagination-CTZw782r.js";import"./Select-BguIcjbH.js";import"./SelectItem-DqTdUuEX.js";import"./ProgressIndicator-DuFaBOSv.js";import"./bucket-9-CWwdCVGV.js";import"./RadioButtonGroup-CzVvexCl.js";import"./TileGroup-BmeXNjH_.js";import"./bucket-14-DJtJQxMb.js";import"./TimePickerSelect-CEJuT0Bb.js";import"./Slider-DjUx93LH.js";import"./StructuredList-C7wStfnY.js";import"./Tabs-BasLLd7o.js";import"./DismissibleTag-CfULJo6W.js";import"./SelectableTag-DHA8qokM.js";import"./TextArea-B64HB26U.js";import"./Tile-Cl28JRy4.js";import"./Toggle-CXFXdIpq.js";import"./Content-CDKtFefv.js";import"./HeaderName-Z790LxE8.js";import"./Link-C50XFcPM.js";import"./HeaderContainer-nxpKhYEA.js";import"./HeaderGlobalBar-BZ68s-iC.js";import"./AriaPropTypes-CzdhBgps.js";import"./SideNavLink-DH6rljtF.js";import"./bucket-11-CYIdE7NI.js";import"./SideNavLinkText-BEaJCOwr.js";import"./HeaderPanel-bYBeWu4w.js";import"./SideNavMenuItem-DntFZ8qZ.js";import"./UnorderedList-DDkJb3R7.js";import"./bucket-5-3PRz3JSU.js";import"./index-BfFE7CSd.js";import"./bucket-7-CvmQKYEr.js";import"./bucket-8-u5sKO1pM.js";import"./bucket-12-CJa06dRK.js";import"./bucket-16-BRL4k4hx.js";import"./bucket-20-CW6YqBtw.js";const Y=".app{margin:.75rem}.app .cds--inline-loading{min-block-size:unset}.notification{position:absolute;inset-block-start:.75rem;inset-inline-end:.75rem}.no-bullets{margin:0;list-style-type:none;padding-inline-start:2rem}";function B(){const o=new Date;let e=o.getHours();const c=o.getMinutes().toString().padStart(2,"0"),a=o.getSeconds().toString().padStart(2,"0"),d=e>=12?"PM":"AM";return e=e%12,e=e||12,`${e}:${c}:${a} ${d}`}const Z=[`import { TrashCan } from '@carbon/react/icons';
  import { InlineLoading } from '@carbon/react';`],$=["import { Launch } from '@carbon/react/icons';"],q=[`${B} ${T}`];function F(o){const e={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...X(),...o.components};return t.jsxs(t.Fragment,{children:[t.jsx(e.h1,{id:"delete-and-remove",children:"Delete and remove"}),`
`,t.jsx(e.p,{children:t.jsx(e.a,{href:"https://pages.github.ibm.com/carbon/ibm-products/patterns/delete-and-remove/usage/",rel:"nofollow",children:"Usage guidelines"})}),`
`,t.jsx(e.h2,{id:"table-of-contents",children:"Table of Contents"}),`
`,t.jsxs(e.ul,{children:[`
`,t.jsx(e.li,{children:t.jsx(e.a,{href:"#overview",children:"Overview"})}),`
`,t.jsx(e.li,{children:t.jsx(e.a,{href:"#high-impact-deletion",children:"High impact deletion"})}),`
`,t.jsx(e.li,{children:t.jsx(e.a,{href:"#high-impact-deletion-with-connected-items",children:"High impact deletion with connected items"})}),`
`,t.jsx(e.li,{children:t.jsx(e.a,{href:"#high-impact-batch-deletion",children:"High impact batch deletion"})}),`
`,t.jsx(e.li,{children:t.jsx(e.a,{href:"#medium-impact-deletion-or-removal",children:"Medium impact deletion or removal"})}),`
`,t.jsx(e.li,{children:t.jsx(e.a,{href:"#low-impact-deletion-or-removal",children:"Low impact deletion or removal"})}),`
`]}),`
`,t.jsx(e.h2,{id:"overview",children:"Overview"}),`
`,t.jsx(e.p,{children:`“Removing” is an action that moves information from one location to another.
Removal can be both destructive and non-destructive. “Deletion” is the most
common type of removal and is destructive`}),`
`,t.jsxs(e.blockquote,{children:[`
`,t.jsx(e.p,{children:`NOTE: Patterns have multiple ways of accomplishing a user need and typically
use a combination of components with additional design considerations. The
pattern code we share is meant to serve as an example implementation that can
be built and extended further.`}),`
`]}),`
`,t.jsx(e.h4,{id:"ingredients",children:"Ingredients"}),`
`,t.jsx(e.p,{children:"To build these patterns, we recommend including the following components:"}),`
`,t.jsx(e.pre,{children:t.jsx(e.code,{className:"language-jsx",children:`import {
  Button,
  Checkbox,
  FormLabel,
  InlineLoading,
  Link,
  Modal,
  TextInput,
  ToastNotification,
} from '@carbon/react';
`})}),`
`,t.jsx(e.h2,{id:"high-impact-deletion",children:"High impact deletion"}),`
`,t.jsx(e.p,{children:`When deleting is high-impact, a confirmation dialog should be presented to the
user which displays:`}),`
`,t.jsxs(e.ul,{children:[`
`,t.jsx(e.li,{children:"The name of the resource"}),`
`,t.jsx(e.li,{children:"Consequences of the deletion"}),`
`,t.jsx(e.li,{children:"This action cannot be undone."}),`
`,t.jsx(e.li,{children:"An editable text field for the name of the resource to be entered"}),`
`]}),`
`,t.jsx(R,{of:b,additionalActions:[{title:"Open in Stackblitz",onClick:()=>E({story:b,customFunctionDefs:q,styles:H.parameters.styles,title:`${b.storyName} pattern (Carbon React)`})}]}),`
`,t.jsx(e.h2,{id:"high-impact-deletion-with-connected-items",children:"High impact deletion with connected items"}),`
`,t.jsx(e.p,{children:`It is similar to high-impact deletion pattern, but the confirmation dialog will
display the below 2 additional content:`}),`
`,t.jsxs(e.ul,{children:[`
`,t.jsx(e.li,{children:"A list of all the connected items"}),`
`,t.jsx(e.li,{children:"A checkbox to confirm the deletion of all its connected items."}),`
`]}),`
`,t.jsx(R,{of:S,additionalActions:[{title:"Open in Stackblitz",onClick:()=>E({story:S,customImports:$,customFunctionDefs:q,styles:H.parameters.styles,title:`${S.storyName} pattern (Carbon React)`})}]}),`
`,t.jsx(e.h2,{id:"high-impact-batch-deletion",children:"High impact batch deletion"}),`
`,t.jsx(e.p,{children:`In batch deletion, a confirmation dialog should be presented to the user which
displays:`}),`
`,t.jsxs(e.ul,{children:[`
`,t.jsx(e.li,{children:"The names of the items selected"}),`
`,t.jsx(e.li,{children:"The consequences of the deletion"}),`
`,t.jsx(e.li,{children:"The phrase, “This action cannot be undone”"}),`
`,t.jsx(e.li,{children:"A checkbox to confirm the deletion of the selected resources"}),`
`,t.jsx(e.li,{children:"A note of items that cannot be deleted in batch selection (optional)"}),`
`]}),`
`,t.jsx(R,{of:x,additionalActions:[{title:"Open in Stackblitz",onClick:()=>E({story:x,customImports:$,customFunctionDefs:q,styles:H.parameters.styles,title:`${x.storyName} pattern (Carbon React)`})}]}),`
`,t.jsx(e.h2,{id:"medium-impact-deletion-or-removal",children:"Medium impact deletion or removal"}),`
`,t.jsx(e.p,{children:`When deleting is medium-impact, the user is not required to confirm the resource
name by typing it into a text field.`}),`
`,t.jsxs(e.blockquote,{children:[`
`,t.jsx(e.p,{children:`NOTE: The medium-impact removal pattern is similar to medium-impact deletion
pattern, with the only difference being the usage of “remove” or “delete“ in
the text. Use “remove” when the action is reversible or not truly destructive.`}),`
`]}),`
`,t.jsx(R,{of:y,additionalActions:[{title:"Open in Stackblitz",onClick:()=>E({story:y,customFunctionDefs:q,styles:H.parameters.styles,title:`${y.storyName} pattern (Carbon React)`})}]}),`
`,t.jsx(e.h2,{id:"low-impact-deletion-or-removal",children:"Low impact deletion or removal"}),`
`,t.jsx(e.p,{children:"In low impact situations, user confirmation may not be required."}),`
`,t.jsxs(e.blockquote,{children:[`
`,t.jsx(e.p,{children:`NOTE: The low-impact removal pattern is similar to low-impact deletion
pattern, with the only difference being the usage of “remove” or “delete“ in
the text.`}),`
`]}),`
`,t.jsx(R,{of:N,additionalActions:[{title:"Open in Stackblitz",onClick:()=>E({story:N,customImports:Z,customFunctionDefs:q,styles:H.parameters.styles,title:`${N.storyName} pattern (Carbon React)`})}]})]})}function ee(o={}){const{wrapper:e}={...X(),...o.components};return e?t.jsx(e,{...o,children:t.jsx(F,{...o})}):F(o)}const H={title:"Patterns/Delete and remove",component:()=>{},tags:["autodocs"],parameters:{styles:Y,docs:{page:ee}}},te=()=>{const[o,e]=i.useState(!1),[c,a]=i.useState(!1),[d,s]=i.useState("inactive"),[m,l]=i.useState("Deleting"),[u,p]=i.useState(!1),[C,f]=i.useState(""),[g,D]=i.useState(!1),L=async()=>(await T(1e3),!0),v=async()=>{a(!0),s("active");const h=await L();a(!1),s("finished"),l("Deleted!"),e(!1),h&&I()},I=()=>{p(!0)},j=()=>{p(!1)},O=h=>{f(h.target.value),h.target.value==="Bx1001"?D(!0):D(!1)},r=()=>{s("inactive"),l("Deleting...")};return n.createElement("div",{className:"app"},n.createElement(k,{size:"md",kind:"danger",onClick:()=>{f(""),e(!0)}},"Delete"),n.createElement(z,{open:o,onRequestClose:()=>e(!1),danger:!0,modalHeading:"Confirm delete",modalLabel:"Delete Bx1001",primaryButtonText:"Delete",secondaryButtonText:"Cancel",onRequestSubmit:v,onSecondarySubmit:()=>e(!1),primaryButtonDisabled:!g,loadingStatus:d,loadingDescription:m,onLoadingSuccess:r},n.createElement("p",{style:{marginBottom:"1rem"}},"Deleting 'Bx1001' will permanently delete the configuration. This action cannot be undone."),n.createElement(P,{"data-modal-primary-focus":!0,id:"text-input-1",labelText:"Type Bx1001 to confirm",placeholder:"Name of resource",value:C,onChange:O})),u&&n.createElement(M,{open:o,"aria-label":"closes notification",caption:B(),kind:"success",lowContrast:!0,onClose:j,role:"status",statusIconDescription:"notification",subtitle:"Bx1001 has been successfully deleted.",timeout:3e3,title:"Success",className:"notification"}))},b=te.bind({});b.storyName="High impact deletion";b.args={};const ne=()=>{const o=[{id:1,name:"Route1_name"},{id:2,name:"Hpt-392-ser"},{id:3,name:"Route2_name"}],[e,c]=i.useState(!1),[a,d]=i.useState(!1),[s,m]=i.useState("inactive"),[l,u]=i.useState("Deleting"),[p,C]=i.useState(!1),[f,g]=i.useState(""),[D,L]=i.useState(!1),[v,I]=i.useState(!1),j=async()=>(await T(1e3),!0),O=async()=>{d(!0),m("active");const w=await j();d(!1),m("finished"),u("Deleted!"),c(!1),w&&r()},r=()=>{C(!0)},h=()=>{C(!1)},U=w=>{g(w.target.value),w.target.value==="Bx1001"?L(!0):L(!1)},G=()=>{m("inactive"),u("Deleting...")};return n.createElement("div",{className:"app"},n.createElement(k,{size:"md",kind:"danger",onClick:()=>{g(""),I(!1),c(!0)}},"Delete"),n.createElement(z,{open:e,onRequestClose:()=>{c(!1)},danger:!0,modalHeading:"Confirm delete",modalLabel:"Delete Bx1001",primaryButtonText:"Delete",secondaryButtonText:"Cancel",onRequestSubmit:O,onSecondarySubmit:()=>c(!1),primaryButtonDisabled:!D||!v,loadingStatus:s,loadingDescription:l,onLoadingSuccess:G},n.createElement("p",{style:{marginBottom:"1rem"}},"When you delete the 'Bx1001', this resource and all connected items are permanently deleted. This action cannot be undone."),n.createElement(P,{"data-modal-primary-focus":!0,value:f,id:"text-input-1",labelText:"Type Bx1001 to confirm",placeholder:"Name of resource",onChange:U,style:{marginBottom:"1rem"}}),n.createElement(W,null,"The following connected items will also be deleted. Review each item to confirm that they can be deleted."),n.createElement(V,{checked:v,id:"checkbox-1",labelText:`${o.length} items: `,onChange:(w,{checked:J})=>I(J)}),n.createElement("ul",{className:"no-bullets"},o.map(w=>n.createElement("li",{key:w.id},n.createElement(_,{href:"#",renderIcon:A},w.name))))),p&&n.createElement(M,{open:e,"aria-label":"closes notification",caption:B(),kind:"success",lowContrast:!0,onClose:h,role:"status",statusIconDescription:"notification",subtitle:"Bx1001 and all connected items have been successfully deleted.",timeout:3e3,title:"Success",className:"notification"}))},S=ne.bind({});S.storyName="Deletion with connected items";S.args={};const ie=()=>{const o=[{id:1,name:"Route1_name"},{id:2,name:"Hpt-392-ser"},{id:3,name:"Route2_name"}],e=[{id:1,name:"Route3_name"},{id:2,name:"Route4_name"}],[c,a]=i.useState(!1),[d,s]=i.useState(!1),[m,l]=i.useState("inactive"),[u,p]=i.useState("Deleting"),[C,f]=i.useState(!1),[g,D]=i.useState(!1),L=async()=>(await T(1e3),!0),v=async()=>{s(!0),l("active");const r=await L();s(!1),l("finished"),p("Deleted!"),a(!1),r&&I()},I=()=>{f(!0)},j=()=>{f(!1)},O=()=>{l("inactive"),p("Deleting...")};return n.createElement("div",{className:"app"},n.createElement(k,{size:"md",kind:"danger",onClick:()=>{D(!1),a(!0)}},"Delete all"),n.createElement(z,{open:c,onRequestClose:()=>{a(!1)},danger:!0,modalHeading:"Confirm delete",modalLabel:"Delete selected items",primaryButtonText:"Delete",secondaryButtonText:"Cancel",onRequestSubmit:v,onSecondarySubmit:()=>a(!1),primaryButtonDisabled:!g,size:"sm",loadingStatus:m,loadingDescription:u,onLoadingSuccess:O},n.createElement("p",{style:{marginBottom:"1rem"}},"Decide if you want to keep these items. Deleting these items is permanent. This action cannot be undone."),n.createElement(W,null,"The following items will be deleted. Review each item to confirm that they can be deleted."),n.createElement(V,{checked:g,id:"checkbox-1",labelText:`${o.length} items: `,onChange:(r,{checked:h})=>D(h)}),n.createElement("ul",{className:"no-bullets"},o.map(r=>n.createElement("li",{key:r.id},n.createElement(_,{href:"#",renderIcon:A},r.name)))),e.length&&n.createElement("p",{style:{marginTop:"1rem"}},"Note - the following selected items cannot be deleted:",e.map((r,h)=>n.createElement("span",{key:r.id},n.createElement(_,{href:"#",renderIcon:A},r.name),h<e.length-1&&", ")))),C&&n.createElement(M,{open:c,"aria-label":"closes notification",caption:B(),kind:"success",lowContrast:!0,onClose:j,role:"status",statusIconDescription:"notification",subtitle:"Selected items have been successfully deleted.",timeout:3e3,title:"Success",className:"notification"}))},x=ie.bind({});x.storyName="Batch deletion";x.args={};const oe=()=>{const[o,e]=i.useState(!1),[c,a]=i.useState(!1),[d,s]=i.useState("inactive"),[m,l]=i.useState("Deleting"),[u,p]=i.useState(!1),C=async()=>(await T(1e3),!0),f=async()=>{a(!0),s("active");const v=await C();a(!1),s("finished"),l("Deleted!"),e(!1),v&&g()},g=()=>{p(!0)},D=()=>{p(!1)},L=()=>{s("inactive"),l("Deleting...")};return n.createElement("div",{className:"app"},n.createElement(k,{size:"md",kind:"danger",onClick:()=>e(!0)},"Delete"),n.createElement(z,{open:o,onRequestClose:()=>e(!1),danger:!0,modalHeading:"Confirm delete",modalLabel:"Delete Bx1001",primaryButtonText:"Delete",secondaryButtonText:"Cancel",onRequestSubmit:f,onSecondarySubmit:()=>e(!1),primaryButtonDisabled:c,loadingStatus:d,loadingDescription:m,onLoadingSuccess:L},n.createElement("p",null,"Deleting 'Bx1001' will permanently delete the configuration. This action cannot be undone.")),u&&n.createElement(M,{open:o,"aria-label":"closes notification",caption:B(),kind:"success",lowContrast:!0,onClose:D,role:"status",statusIconDescription:"notification",subtitle:"Bx1001 has been successfully deleted.",timeout:3e3,title:"Success",className:"notification"}))},y=oe.bind({});y.storyName="Medium impact deletion";y.args={};const ae=()=>{const[o,e]=i.useState(!1),[c,a]=i.useState(!1),d=async()=>(await T(1e3),!0),s=async()=>{a(!0);const u=await d();a(!1),u&&m()},m=()=>{e(!0)},l=()=>{e(!1)};return n.createElement("div",{className:"app"},c?n.createElement(k,{size:"md",kind:"danger",iconDescription:"Loading",renderIcon:K},"Deleting..."):n.createElement(k,{size:"md",kind:"danger",iconDescription:"TrashCan",renderIcon:Q,onClick:s},"Delete"),o&&n.createElement(M,{open:o,"aria-label":"closes notification",caption:B(),kind:"success",lowContrast:!0,onClose:l,role:"status",statusIconDescription:"notification",subtitle:"Bx1001 has been successfully deleted.",timeout:3e3,title:"Success",className:"notification"}))},N=ae.bind({});N.storyName="Low impact deletion";N.args={};b.parameters={...b.parameters,docs:{...b.parameters?.docs,source:{originalSource:`() => {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [loadingStatus, setLoadingStatus] = useState('inactive');
  const [loaderDescription, setLoaderDescription] = useState('Deleting');
  const [openNotification, setOpenNotification] = useState(false);
  const [resourceName, setResourceName] = useState('');
  const [isValidName, setIsValidName] = useState(false);
  const deleteItem = async () => {
    await wait(1000);
    return true;
  };
  const handleDelete = async () => {
    setLoading(true);
    setLoadingStatus('active');
    const isDelete = await deleteItem();
    setLoading(false);
    setLoadingStatus('finished');
    setLoaderDescription('Deleted!');
    setOpen(false);
    isDelete && showNotification();
  };
  const showNotification = () => {
    setOpenNotification(true);
  };
  const hideNotification = () => {
    setOpenNotification(false);
  };
  const validateInput = evt => {
    setResourceName(evt.target.value);
    if (evt.target.value === 'Bx1001') {
      setIsValidName(true);
    } else {
      setIsValidName(false);
    }
  };
  const resetLoaderStatus = () => {
    setLoadingStatus('inactive');
    setLoaderDescription('Deleting...');
  };
  return <div className="app">
      <Button size="md" kind="danger" onClick={() => {
      // Clear form
      setResourceName('');
      // show confirmation modal
      setOpen(true);
    }}>
        Delete
      </Button>
      <Modal open={open} onRequestClose={() => setOpen(false)} danger modalHeading="Confirm delete" modalLabel="Delete Bx1001" primaryButtonText="Delete" secondaryButtonText="Cancel" onRequestSubmit={handleDelete} onSecondarySubmit={() => setOpen(false)} primaryButtonDisabled={!isValidName} loadingStatus={loadingStatus} loadingDescription={loaderDescription} onLoadingSuccess={resetLoaderStatus}>
        <p style={{
        marginBottom: '1rem'
      }}>
          Deleting 'Bx1001' will permanently delete the configuration. This
          action cannot be undone.
        </p>
        <TextInput data-modal-primary-focus id="text-input-1" labelText="Type Bx1001 to confirm" placeholder="Name of resource" value={resourceName} onChange={validateInput} />
      </Modal>
      {openNotification && <ToastNotification open={open} aria-label="closes notification" caption={getCurrentTime()} kind="success" lowContrast onClose={hideNotification} role="status" statusIconDescription="notification" subtitle="Bx1001 has been successfully deleted." timeout={3000} title="Success" className="notification" />}
    </div>;
}`,...b.parameters?.docs?.source}}};S.parameters={...S.parameters,docs:{...S.parameters?.docs,source:{originalSource:`() => {
  const connectedItems = [{
    id: 1,
    name: 'Route1_name'
  }, {
    id: 2,
    name: 'Hpt-392-ser'
  }, {
    id: 3,
    name: 'Route2_name'
  }];
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [loadingStatus, setLoadingStatus] = useState('inactive');
  const [loaderDescription, setLoaderDescription] = useState('Deleting');
  const [openNotification, setOpenNotification] = useState(false);
  const [resourceName, setResourceName] = useState('');
  const [isValidName, setIsValidName] = useState(false);
  const [isChecked, setIsChecked] = useState(false);
  const deleteItem = async () => {
    await wait(1000);
    return true;
  };
  const handleDelete = async () => {
    setLoading(true);
    setLoadingStatus('active');
    const isDelete = await deleteItem();
    setLoading(false);
    setLoadingStatus('finished');
    setLoaderDescription('Deleted!');
    setOpen(false);
    isDelete && showNotification();
  };
  const showNotification = () => {
    setOpenNotification(true);
  };
  const hideNotification = () => {
    setOpenNotification(false);
  };
  const validateInput = evt => {
    setResourceName(evt.target.value);
    if (evt.target.value === 'Bx1001') {
      setIsValidName(true);
    } else {
      setIsValidName(false);
    }
  };
  const resetLoaderStatus = () => {
    setLoadingStatus('inactive');
    setLoaderDescription('Deleting...');
  };
  return <div className="app">
      <Button size="md" kind="danger" onClick={() => {
      // Clear form
      setResourceName('');
      setIsChecked(false);
      // show confirmation modal
      setOpen(true);
    }}>
        Delete
      </Button>
      <Modal open={open} onRequestClose={() => {
      setOpen(false);
    }} danger modalHeading="Confirm delete" modalLabel="Delete Bx1001" primaryButtonText="Delete" secondaryButtonText="Cancel" onRequestSubmit={handleDelete} onSecondarySubmit={() => setOpen(false)} primaryButtonDisabled={!isValidName || !isChecked} loadingStatus={loadingStatus} loadingDescription={loaderDescription} onLoadingSuccess={resetLoaderStatus}>
        <p style={{
        marginBottom: '1rem'
      }}>
          When you delete the 'Bx1001', this resource and all connected items
          are permanently deleted. This action cannot be undone.
        </p>
        <TextInput data-modal-primary-focus value={resourceName} id="text-input-1" labelText="Type Bx1001 to confirm" placeholder="Name of resource" onChange={validateInput} style={{
        marginBottom: '1rem'
      }} />
        <FormLabel>
          The following connected items will also be deleted. Review each item
          to confirm that they can be deleted.
        </FormLabel>
        <Checkbox checked={isChecked} id="checkbox-1" labelText={\`\${connectedItems.length} items: \`} onChange={(event, {
        checked
      }) => setIsChecked(checked)} />
        <ul className="no-bullets">
          {connectedItems.map(item => <li key={item.id}>
              <Link href="#" renderIcon={Launch}>
                {item.name}
              </Link>
            </li>)}
        </ul>
      </Modal>
      {openNotification && <ToastNotification open={open} aria-label="closes notification" caption={getCurrentTime()} kind="success" lowContrast onClose={hideNotification} role="status" statusIconDescription="notification" subtitle="Bx1001 and all connected items have been successfully deleted." timeout={3000} title="Success" className="notification" />}
    </div>;
}`,...S.parameters?.docs?.source}}};x.parameters={...x.parameters,docs:{...x.parameters?.docs,source:{originalSource:`() => {
  const batchItems = [{
    id: 1,
    name: 'Route1_name'
  }, {
    id: 2,
    name: 'Hpt-392-ser'
  }, {
    id: 3,
    name: 'Route2_name'
  }];
  const protectedItems = [{
    id: 1,
    name: 'Route3_name'
  }, {
    id: 2,
    name: 'Route4_name'
  }];
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [loadingStatus, setLoadingStatus] = useState('inactive');
  const [loaderDescription, setLoaderDescription] = useState('Deleting');
  const [openNotification, setOpenNotification] = useState(false);
  const [isChecked, setIsChecked] = useState(false);
  const deleteItem = async () => {
    await wait(1000);
    return true;
  };
  const handleDelete = async () => {
    setLoading(true);
    setLoadingStatus('active');
    const isDelete = await deleteItem();
    setLoading(false);
    setLoadingStatus('finished');
    setLoaderDescription('Deleted!');
    setOpen(false);
    isDelete && showNotification();
  };
  const showNotification = () => {
    setOpenNotification(true);
  };
  const hideNotification = () => {
    setOpenNotification(false);
  };
  const resetLoaderStatus = () => {
    setLoadingStatus('inactive');
    setLoaderDescription('Deleting...');
  };
  return <div className="app">
      <Button size="md" kind="danger" onClick={() => {
      // Clear form
      setIsChecked(false);
      // show confirmation modal
      setOpen(true);
    }}>
        Delete all
      </Button>
      <Modal open={open} onRequestClose={() => {
      setOpen(false);
    }} danger modalHeading="Confirm delete" modalLabel="Delete selected items" primaryButtonText="Delete" secondaryButtonText="Cancel" onRequestSubmit={handleDelete} onSecondarySubmit={() => setOpen(false)} primaryButtonDisabled={!isChecked} size="sm" loadingStatus={loadingStatus} loadingDescription={loaderDescription} onLoadingSuccess={resetLoaderStatus}>
        <p style={{
        marginBottom: '1rem'
      }}>
          Decide if you want to keep these items. Deleting these items is
          permanent. This action cannot be undone.
        </p>
        <FormLabel>
          The following items will be deleted. Review each item to confirm that
          they can be deleted.
        </FormLabel>
        <Checkbox checked={isChecked} id="checkbox-1" labelText={\`\${batchItems.length} items: \`} onChange={(event, {
        checked
      }) => setIsChecked(checked)} />
        <ul className="no-bullets">
          {batchItems.map(item => <li key={item.id}>
              <Link href="#" renderIcon={Launch}>
                {item.name}
              </Link>
            </li>)}
        </ul>

        {protectedItems.length && <p style={{
        marginTop: '1rem'
      }}>
            Note - the following selected items cannot be deleted:
            {protectedItems.map((item, index) => <span key={item.id}>
                <Link href="#" renderIcon={Launch}>
                  {item.name}
                </Link>
                {index < protectedItems.length - 1 && ', '}
              </span>)}
          </p>}
      </Modal>
      {openNotification && <ToastNotification open={open} aria-label="closes notification" caption={getCurrentTime()} kind="success" lowContrast onClose={hideNotification} role="status" statusIconDescription="notification" subtitle="Selected items have been successfully deleted." timeout={3000} title="Success" className="notification" />}
    </div>;
}`,...x.parameters?.docs?.source}}};y.parameters={...y.parameters,docs:{...y.parameters?.docs,source:{originalSource:`() => {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const [loadingStatus, setLoadingStatus] = useState('inactive');
  const [loaderDescription, setLoaderDescription] = useState('Deleting');
  const [openNotification, setOpenNotification] = useState(false);
  const deleteItem = async () => {
    await wait(1000);
    return true;
  };
  const handleDelete = async () => {
    setLoading(true);
    setLoadingStatus('active');
    const isDelete = await deleteItem();
    setLoading(false);
    setLoadingStatus('finished');
    setLoaderDescription('Deleted!');
    setOpen(false);
    isDelete && showNotification();
  };
  const showNotification = () => {
    setOpenNotification(true);
  };
  const hideNotification = () => {
    setOpenNotification(false);
  };
  const resetLoaderStatus = () => {
    setLoadingStatus('inactive');
    setLoaderDescription('Deleting...');
  };
  return <div className="app">
      <Button size="md" kind="danger" onClick={() => setOpen(true)}>
        Delete
      </Button>
      <Modal open={open} onRequestClose={() => setOpen(false)} danger modalHeading="Confirm delete" modalLabel="Delete Bx1001" primaryButtonText="Delete" secondaryButtonText="Cancel" onRequestSubmit={handleDelete} onSecondarySubmit={() => setOpen(false)} primaryButtonDisabled={loading} loadingStatus={loadingStatus} loadingDescription={loaderDescription} onLoadingSuccess={resetLoaderStatus}>
        <p>
          Deleting 'Bx1001' will permanently delete the configuration. This
          action cannot be undone.
        </p>
      </Modal>
      {openNotification && <ToastNotification open={open} aria-label="closes notification" caption={getCurrentTime()} kind="success" lowContrast onClose={hideNotification} role="status" statusIconDescription="notification" subtitle="Bx1001 has been successfully deleted." timeout={3000} title="Success" className="notification" />}
    </div>;
}`,...y.parameters?.docs?.source}}};N.parameters={...N.parameters,docs:{...N.parameters?.docs,source:{originalSource:`() => {
  const [open, setOpen] = useState(false);
  const [loading, setLoading] = useState(false);
  const deleteItem = async () => {
    await wait(1000);
    return true;
  };
  const handleDelete = async () => {
    setLoading(true);
    const isDelete = await deleteItem();
    setLoading(false);
    isDelete && showNotification();
  };
  const showNotification = () => {
    setOpen(true);
  };
  const hideNotification = () => {
    setOpen(false);
  };
  return <div className="app">
      {loading ? <Button size="md" kind="danger" iconDescription="Loading" renderIcon={InlineLoading}>
          Deleting...
        </Button> : <Button size="md" kind="danger" iconDescription="TrashCan" renderIcon={TrashCan} onClick={handleDelete}>
          Delete
        </Button>}
      {open && <ToastNotification open={open} aria-label="closes notification" caption={getCurrentTime()} kind="success" lowContrast onClose={hideNotification} role="status" statusIconDescription="notification" subtitle="Bx1001 has been successfully deleted." timeout={3000} title="Success" className="notification" />}
    </div>;
}`,...N.parameters?.docs?.source}}};const rn=["highImpactDeletion","highImpactDeletionWithConnectedItems","highImpactBatchDeletion","mediumImpactDeletion","lowImpactDeletion"];export{rn as __namedExportsOrder,H as default,x as highImpactBatchDeletion,b as highImpactDeletion,S as highImpactDeletionWithConnectedItems,N as lowImpactDeletion,y as mediumImpactDeletion};
//# sourceMappingURL=DeleteAndRemove.stories-nXkoFsyT.js.map
