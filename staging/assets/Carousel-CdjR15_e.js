import{e as a,r as l}from"./index-DtHxqM--.js";import{d as q,P as s,b as X}from"./index-C360Eztx.js";import{g as j}from"./devtools-XPxnGn1y.js";import{p as F}from"./settings-CFkY3W_8.js";import{u as M}from"./useIsomorphicEffect-DztsuiUB.js";const Y=`${F.prefix}--carousel__item`,z="CarouselItem",v=a.forwardRef(({children:C,className:E,...g},S)=>a.createElement("div",{...g,className:q(Y,E),...j(z),ref:S},C));v.displayName=z;v.propTypes={children:s.node.isRequired,className:s.string};v.__docgenInfo={description:"TODO: A description of the component.",methods:[],displayName:"CarouselItem",props:{children:{required:!0,tsType:{name:"ReactNode"},description:"Provide the contents of the CarouselItem.",type:{name:"node"}},className:{required:!1,tsType:{name:"string"},description:"Provide an optional class to be applied to the containing node.",type:{name:"string"}}}};const h=`${F.prefix}--carousel`,H="Carousel",I={disableArrowScroll:!1,onScroll:()=>{},onChangeIsScrollable:()=>{}},T=a.forwardRef((C,E)=>{const{children:g,className:S,disableArrowScroll:x=I.disableArrowScroll,fadedEdgeColor:i,onChangeIsScrollable:N=I.onChangeIsScrollable,onScroll:L=I.onScroll,isScrollMode:K=!1,...Q}=C,R=l.useRef(null),r=l.useRef(null),u=l.useRef(null),d=l.useRef(null),b=l.useRef(Array(a.Children.count(g)).fill(l.useRef(null))),$=typeof i=="object"?i==null?void 0:i.left:i,k=typeof i=="object"?i==null?void 0:i.right:i,A=X(),f=l.useCallback(()=>{var m,p,w;if(!r.current)return;const e=(m=r.current)==null?void 0:m.clientWidth,t=parseInt(`${(p=r.current)==null?void 0:p.scrollLeft}`,10),n=(w=r.current)==null?void 0:w.scrollWidth,o=n-e,c=parseFloat((t/o).toFixed(2))||0;N(n>e),L(c)},[N,L]),P=l.useCallback((e,t)=>{const n=t.left>=e.left,o=t.right<=e.right;return n&&o},[]),_=l.useCallback(()=>{var n;const e=(n=r==null?void 0:r.current)==null?void 0:n.getBoundingClientRect();return b.current.filter(o=>P(e,o.getBoundingClientRect()))},[P]),y=l.useCallback(()=>{var o;const e=(o=r==null?void 0:r.current)==null?void 0:o.getBoundingClientRect(),t=_().map(c=>c.getBoundingClientRect()),n=t.reduce((c,m)=>c+m.width,0);return{containerRect:e,elementRectsInView:t,visibleWidth:n}},[_]),V=l.useCallback(()=>{if(!r.current)return;const{containerRect:e,visibleWidth:t}=y(),n=t>0?t:e==null?void 0:e.width;r.current.scrollLeft+=n},[y]),W=l.useCallback(()=>{if(!r.current)return;const{containerRect:e,elementRectsInView:t,visibleWidth:n}=y(),o=n>0?n-t[0].left:((e==null?void 0:e.width)??0)+((e==null?void 0:e.left)??0);r.current.scrollLeft-=o},[y]),O=l.useCallback(()=>{r.current&&(r.current.scrollLeft=0,f())},[f]),B=l.useCallback(e=>{D(e),b.current[e].scrollIntoView()},[]),G=e=>{const t=`:not(.${A}--visually-hidden,.${A}--btn--disabled,[aria-hidden="true"],[disabled])`,n=`button${t}`,o=`input${t}`,c=`select${t}`,m=`textarea${t}`,p=`[href]${t}`,w=`a${t}`,J=`[tabindex="0"]${t}`,U=`${n},${p},${w},${o},${c},${m},${J}`;return(e==null?void 0:e.querySelectorAll(`${U}`))??[]},D=e=>{var t;!K&&((t=b.current)==null||t.forEach((n,o)=>{const c=o===e;n==null||n.setAttribute("aria-hidden",String(!c)),G(n).forEach(p=>{p.tabIndex=c?0:-1})}))};return l.useEffect(()=>{setTimeout(()=>{D(0),f()},0)},[]),l.useEffect(()=>{const e=()=>{r.current&&(r.current.scrollLeft=0,f())};return window.addEventListener("resize",e),()=>window.removeEventListener("resize",e)},[f]),l.useEffect(()=>{const e=()=>{f()},t=r.current;return t==null||t.addEventListener("scrollend",e),()=>t==null?void 0:t.removeEventListener("scrollend",e)},[f]),l.useEffect(()=>{function e(n){n.shiftKey&&(n.stopPropagation(),n.preventDefault(),n.cancelBubble=!1)}const t=r.current;if(t)return t.addEventListener("wheel",e,{passive:!1}),()=>{t.removeEventListener("wheel",e)}},[]),l.useEffect(()=>{function e(n){const{key:o}=n;(o==="ArrowLeft"||o==="ArrowRight")&&x&&(n.stopPropagation(),n.preventDefault(),n.cancelBubble=!1)}const t=R.current;if(t)return t.addEventListener("keydown",e),()=>t.removeEventListener("keydown",e)},[x]),l.useImperativeHandle(E,()=>({scrollNext(){V()},scrollPrev(){W()},scrollReset(){O()},scrollToView(e){B(e)}}),[V,W,O,B]),M(()=>{u!=null&&u.current&&u.current.style&&(u.current.style.background=`linear-gradient(90deg, ${$}, transparent)`)},[u,$]),M(()=>{d!=null&&d.current&&d.current.style&&(d.current.style.background=`linear-gradient(270deg, ${k}, transparent)`)},[d,k]),a.createElement("div",{...Q,tabIndex:-1,className:q(h,S),ref:R,...j(H)},a.createElement("div",{className:q(`${h}__elements-container`)},a.createElement("div",{className:`${h}__elements`,ref:r},a.Children.map(g,(e,t)=>a.createElement(v,{key:t,ref:n=>{b.current[t]=n}},e))),$&&a.createElement("div",{ref:u,className:`${h}__elements-container--scrolled`}),k&&a.createElement("div",{ref:d,className:`${h}__elements-container--scroll-max`})))});T.displayName=H;T.propTypes={children:s.node.isRequired,className:s.string,disableArrowScroll:s.bool,fadedEdgeColor:s.oneOfType([s.string,s.shape({left:s.string,right:s.string})]),isScrollMode:s.bool,onChangeIsScrollable:s.func,onScroll:s.func};T.__docgenInfo={description:`The Carousel acts as a scaffold for other Onboarding content.

This component is not intended for general use.

Expected scrolling behavior.
1. Scroll the maximum number of visible items at a time.
2. The left-most item should always be left-aligned in the viewport.

Exception.
1. After scrolling to the last (right-most) item,
     if some of its content remains hidden,
     then nudge it to the right until it is right-aligned.
2. From the right-aligned position, when scrolling left,
     the left-most item should again be left-aligned.`,methods:[{name:"scrollNext",docblock:null,modifiers:[],params:[],returns:null},{name:"scrollPrev",docblock:null,modifiers:[],params:[],returns:null},{name:"scrollReset",docblock:null,modifiers:[],params:[],returns:null},{name:"scrollToView",docblock:null,modifiers:[],params:[{name:"itemNumber",optional:!1,type:null}],returns:null}],displayName:"Carousel",props:{children:{required:!0,tsType:{name:"ReactNode"},description:"Provide the contents of the Carousel.",type:{name:"node"}},className:{required:!1,tsType:{name:"string"},description:"Provide an optional class to be applied to the containing node.",type:{name:"string"}},disableArrowScroll:{required:!1,tsType:{name:"boolean"},description:`Disables the ability of the Carousel to scroll
use a keyboard's left and right arrow keys.`,type:{name:"bool"}},fadedEdgeColor:{required:!1,tsType:{name:"union",raw:"string | { left: string; right: string }",elements:[{name:"string"},{name:"signature",type:"object",raw:"{ left: string; right: string }",signature:{properties:[{key:"left",value:{name:"string",required:!0}},{key:"right",value:{name:"string",required:!0}}]}}]},description:"Enables the edges of the component to have faded styling.\n\nPass a single string (`$color`) to specify the same color for left and right.\n\nOr pass an object (`{ left: $color1, right: $color2 }`) to specify different colors.",type:{name:"union",value:[{name:"string"},{name:"shape",value:{left:{name:"string",required:!1},right:{name:"string",required:!1}}}]}},onChangeIsScrollable:{required:!1,tsType:{name:"signature",type:"function",raw:"(isScrollable: boolean) => void",signature:{arguments:[{type:{name:"boolean"},name:"isScrollable"}],return:{name:"void"}}},description:"An optional callback function that returns `true`\nwhen the carousel has enough content to be scrollable,\nand `false` when there is not enough content.",type:{name:"func"}},onScroll:{required:!1,tsType:{name:"signature",type:"function",raw:"(scrollPercent: number) => void",signature:{arguments:[{type:{name:"number"},name:"scrollPercent"}],return:{name:"void"}}},description:`An optional callback function that returns the scroll position as
a value between 0 and 1.`,type:{name:"func"}},isScrollMode:{required:!1,tsType:{name:"boolean"},description:`enable scroll mode when only scroll functionality is required, more than one items will be visible at a time
when isScrollMode is false, component behaves like a carousal and on item will be active at a time
and other items will be hidden and inactive.`,type:{name:"bool"}}}};export{T as C};
