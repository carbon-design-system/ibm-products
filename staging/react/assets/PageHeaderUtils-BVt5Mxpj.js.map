{"version":3,"file":"PageHeaderUtils-BVt5Mxpj.js","sources":["../../src/global/js/utils/scrollableAncestor.js","../../src/components/PageHeader/PageHeaderUtils.js"],"sourcesContent":["/**\n * Copyright IBM Corp. 2024\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nconst windowExists = typeof window !== `undefined`;\n\n// determine whether the target is scrollable\nconst scrollable = (target) => {\n  const style = window.getComputedStyle(target);\n  return /(auto|scroll|hidden)/.test(style.overflow);\n};\n\nconst scrollableAncestorInner = (target) => {\n  if (target.parentNode && target.parentNode !== document) {\n    if (scrollable(target.parentNode)) {\n      return target.parentNode;\n    } else {\n      return scrollableAncestorInner(target.parentNode);\n    }\n  } else {\n    return document.scrollingElement;\n  }\n};\n\n/**\n * Walks up the parent nodes to identify the first scrollable ancestor\n *\n * @param {HTMLElement} target\n * @returns {HTMLElement}\n */\nexport const scrollableAncestor = (target) => {\n  if (!windowExists || !target) {\n    return null;\n  }\n\n  // based on https://stackoverflow.com/questions/35939886/find-first-scrollable-parent\n  const style = window.getComputedStyle(target);\n\n  if (!target || !style || style.position === 'fixed') {\n    return document.scrollingElement;\n  }\n  return scrollableAncestorInner(target);\n};\n","/**\n * Copyright IBM Corp. 2020, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport React from 'react';\nimport cx from 'classnames';\nimport { pkg } from '../../settings';\nimport { scrollableAncestor } from '../../global/js/utils/scrollableAncestor';\nimport { SkeletonText } from '@carbon/react';\n\nexport const blockClass = `${pkg.prefix}--page-header`;\n\n/**\n * Assesses the vertical height of various elements and calls setMetrics with update\n * @param {{}} headerRef\n * @param {{}} offsetTopMeasuringRef\n * @param {object} navigation\n * @param {boolean} enableBreadcrumbScroll\n * @param {boolean} hasActionBar\n * @param {boolean} widthIsNarrow\n * @param {()} setMetrics\n */\nexport const utilCheckUpdateVerticalSpace = (\n  headerRef,\n  offsetTopMeasuringRef,\n  navigation,\n  enableBreadcrumbScroll,\n  hasActionBar,\n  widthIsNarrow,\n  setMetrics\n) => {\n  const dynamicRefs = {};\n\n  const getDynamicRef = (selector) => {\n    // would love to do this differently but digging in the dom seems easier\n    // than getting a ref to a conditionally rendered item\n    /* don't know how to test resize */\n    /* istanbul ignore if */\n    if (!headerRef.current) {\n      return undefined;\n    } else {\n      let dRef = dynamicRefs[selector];\n      /* istanbul ignore else */\n      if (!dRef || /* istanbul ignore next */ dRef.parentNode === null) {\n        dynamicRefs[selector] = headerRef.current.querySelector(selector);\n      }\n    }\n    return dynamicRefs[selector];\n  };\n\n  setMetrics((previous) => {\n    // Utility function that checks the heights of various elements which are used to determine layout\n    const update = {};\n\n    const breadcrumbTitleEl = getDynamicRef(`.${blockClass}__breadcrumb-title`);\n    const breadcrumbRowEl = getDynamicRef(`.${blockClass}__breadcrumb-row`);\n    const titleRowEl = getDynamicRef(`.${blockClass}__title-row`);\n    const subtitleRowEl = getDynamicRef(`.${blockClass}__subtitle-row`);\n    const availableRowEl = getDynamicRef(`.${blockClass}__available-row`);\n    const navigationRowEl = getDynamicRef(`.${blockClass}__navigation-row`);\n    const pageActionsEl = getDynamicRef(`.${blockClass}__page-actions`);\n\n    /* istanbul ignore next */\n    update.headerHeight = headerRef.current\n      ? headerRef.current.clientHeight\n      : 0;\n    /* istanbul ignore next */\n    update.headerWidth = headerRef.current ? headerRef.current.offsetWidth : 0;\n\n    // The header offset is the vertical distance from the top of the document to\n    // the page header, which we obtain using getBoundingClientRect() for robust\n    // behavior. We use this offset as the scroll/fixed threshold.\n    const scrollableContainer = scrollableAncestor(headerRef.current);\n\n    /* istanbul ignore next */ const scrollableContainerTop =\n      scrollableContainer ? scrollableContainer.getBoundingClientRect().top : 0;\n\n    /* istanbul ignore next */ const offsetMeasuringTop =\n      offsetTopMeasuringRef.current\n        ? offsetTopMeasuringRef.current.getBoundingClientRect().top\n        : 0;\n\n    // The header offset calculation is either going to work out at 0 if we have no gap between scrolling container\n    // top and the measuring ref top, or the difference between.\n    update.headerOffset =\n      offsetMeasuringTop !== 0\n        ? offsetMeasuringTop - scrollableContainerTop\n        : 0;\n\n    /* istanbul ignore next */\n    update.breadcrumbRowHeight = breadcrumbRowEl\n      ? breadcrumbRowEl.clientHeight\n      : 0;\n    /* istanbul ignore next */\n    update.breadcrumbRowWidth = breadcrumbRowEl\n      ? breadcrumbRowEl.offsetWidth\n      : 0;\n\n    /* istanbul ignore next */\n    update.breadcrumbTitleHeight = breadcrumbTitleEl\n      ? breadcrumbTitleEl.offsetHeight // clientHeight returns 0 when window small\n      : 1;\n\n    /* istanbul ignore next */\n    update.titleRowHeight = titleRowEl ? titleRowEl.clientHeight : 0;\n    /* istanbul ignore next */\n    update.subtitleRowHeight = subtitleRowEl ? subtitleRowEl.clientHeight : 0;\n    /* istanbul ignore next */\n    update.availableRowHeight = availableRowEl\n      ? availableRowEl.clientHeight\n      : 0;\n    /* istanbul ignore next */\n    update.navigationRowHeight = navigationRowEl\n      ? navigationRowEl.clientHeight\n      : 1;\n\n    // Base for calculating sticky top\n    update.headerTopValue = -update.headerHeight;\n    if (navigation) {\n      // adjust top for sticky with navigation\n      update.headerTopValue += update.navigationRowHeight;\n    }\n\n    if (!enableBreadcrumbScroll || !navigation) {\n      // adjust sticky top if no navigation or breadcrumb is to stay on screen\n      update.headerTopValue += update.breadcrumbRowHeight;\n    }\n\n    if (enableBreadcrumbScroll) {\n      // adjust header top value when scroll enabled for breadcrumb\n      update.headerTopValue -= navigation\n        ? hasActionBar\n          ? 0\n          : 10\n        : update.headerHeight;\n    }\n\n    // if (window) {\n    let val;\n    /* don't know how to test resize */\n    /* istanbul ignore if */\n    if (breadcrumbRowEl) {\n      val = parseFloat(\n        window\n          .getComputedStyle(breadcrumbRowEl)\n          .getPropertyValue('margin-bottom'),\n        10\n      );\n      update.breadcrumbRowSpaceBelow = isNaN(val) ? 0 : val;\n    }\n    /* don't know how to test resize */\n    /* istanbul ignore if */\n    if (titleRowEl) {\n      val = parseFloat(\n        window.getComputedStyle(titleRowEl).getPropertyValue('margin-top'),\n        10\n      );\n      update.titleRowSpaceAbove = isNaN(val) ? 0 : val;\n\n      if (pageActionsEl) {\n        val = parseFloat(\n          window.getComputedStyle(pageActionsEl).getPropertyValue('margin-top'),\n          10\n        );\n        update.pageActionsSpaceAbove =\n          titleRowEl.clientHeight -\n          pageActionsEl.clientHeight +\n          update.titleRowSpaceAbove -\n          (isNaN(val) ? 0 : val);\n      }\n    }\n    if (!hasActionBar && pageActionsEl) {\n      // adjust headerTopValue when there are no page actions or action bar items (margin above title row)\n      update.headerTopValue -= update.titleRowSpaceAbove;\n    }\n\n    return { ...previous, ...update };\n  });\n};\n\n// Trigger a window scroll, if necessary, to set the collapsed state.\nexport const utilSetCollapsed = (\n  collapse,\n  headerRef,\n  headerOffset,\n  headerTopValue\n) => {\n  /* don't know how to test resize */\n  /* istanbul ignore else */\n  let scrollableTarget = scrollableAncestor(headerRef.current);\n\n  if (collapse) {\n    scrollableTarget.scrollTo({\n      top: headerOffset - headerTopValue,\n      behavior: 'smooth',\n    });\n  } else {\n    scrollableTarget.scrollTo({ top: 0, behavior: 'smooth' });\n  }\n};\n\nexport const utilGetBreadcrumbItemForTitle = (\n  blockClass,\n  collapseTitle,\n  title\n) => {\n  let breadcrumbTitle;\n  if (title) {\n    if (title.text !== undefined) {\n      // Shape title provided\n      breadcrumbTitle = {\n        label: title.loading ? <SkeletonText /> : title.text,\n        title: title.text,\n      };\n    } else if (title.content !== undefined) {\n      // user defined content\n      breadcrumbTitle = {\n        label: title.breadcrumbContent ?? title.content ?? title.asText,\n        title: title.asText,\n      };\n    } else {\n      breadcrumbTitle = {\n        label: title,\n        title,\n      };\n    }\n    if (breadcrumbTitle) {\n      breadcrumbTitle.key = 'breadcrumb-title';\n      breadcrumbTitle.isCurrentPage = true;\n      breadcrumbTitle.href = '#';\n      breadcrumbTitle.className = cx([\n        `${blockClass}__breadcrumb-title`,\n        {\n          [`${blockClass}__breadcrumb-title--pre-collapsed`]: collapseTitle,\n        },\n      ]);\n    }\n\n    if (title.shortTitle) {\n      breadcrumbTitle.shortTitle = title.shortTitle;\n    }\n\n    return breadcrumbTitle;\n  }\n};\n"],"names":["windowExists","scrollable","target","style","scrollableAncestorInner","scrollableAncestor","blockClass","pkg","utilCheckUpdateVerticalSpace","headerRef","offsetTopMeasuringRef","navigation","enableBreadcrumbScroll","hasActionBar","widthIsNarrow","setMetrics","dynamicRefs","getDynamicRef","selector","dRef","previous","update","breadcrumbTitleEl","breadcrumbRowEl","titleRowEl","subtitleRowEl","availableRowEl","navigationRowEl","pageActionsEl","scrollableContainer","scrollableContainerTop","offsetMeasuringTop","val","utilSetCollapsed","collapse","headerOffset","headerTopValue","scrollableTarget","utilGetBreadcrumbItemForTitle","collapseTitle","title","breadcrumbTitle","React","SkeletonText","cx"],"mappings":"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"}