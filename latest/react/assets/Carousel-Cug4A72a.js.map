{"version":3,"file":"Carousel-Cug4A72a.js","sources":["../../src/components/Carousel/CarouselItem.tsx","../../src/components/Carousel/Carousel.tsx"],"sourcesContent":["/**\n * Copyright IBM Corp. 2023, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport React, { ReactNode } from 'react';\n\n// Other standard imports.\nimport PropTypes from 'prop-types';\nimport cx from 'classnames';\n\nimport { getDevtoolsProps } from '../../global/js/utils/devtools';\nimport { pkg } from '../../settings';\n\ninterface CarouselItemProps {\n  /**\n   * Provide the contents of the CarouselItem.\n   */\n  children: ReactNode;\n\n  /**\n   * Provide an optional class to be applied to the containing node.\n   */\n  className?: string;\n}\n\n// Carbon and package components we use.\n/* TODO: @import(s) of carbon components and other package components. */\n\n// The block part of our conventional BEM class names (blockClass__E--M).\nconst blockClass = `${pkg.prefix}--carousel__item`;\nconst componentName = 'CarouselItem';\n\n/**\n * TODO: A description of the component.\n */\nconst CarouselItem = React.forwardRef<HTMLDivElement, CarouselItemProps>(\n  ({ children, className, ...rest }, ref) => {\n    return (\n      <div\n        {...rest}\n        className={cx(blockClass, className)}\n        {...getDevtoolsProps(componentName)}\n        ref={ref}\n      >\n        {children}\n      </div>\n    );\n  }\n);\n\nCarouselItem.displayName = componentName;\n// The types and DocGen commentary for the component props,\n// in alphabetical order (for consistency).\n// See https://www.npmjs.com/package/prop-types#usage.\nCarouselItem.propTypes = {\n  /**\n   * Provide the contents of the CarouselItem.\n   */\n  children: PropTypes.node.isRequired,\n\n  /**\n   * Provide an optional class to be applied to the containing node.\n   */\n  className: PropTypes.string,\n};\n\nexport { CarouselItem };\n","/**\n * Copyright IBM Corp. 2023, 2023\n *\n * This source code is licensed under the Apache-2.0 license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport React, {\n  ReactNode,\n  RefObject,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useRef,\n} from 'react';\n\nimport PropTypes from 'prop-types';\nimport { CarouselItem } from './CarouselItem';\nimport cx from 'classnames';\nimport { getDevtoolsProps } from '../../global/js/utils/devtools';\nimport { pkg } from '../../settings';\nimport { useIsomorphicEffect } from '../../global/js/hooks';\nimport { usePrefix } from '@carbon/react';\n\ntype Handle = {\n  scrollNext?: () => void;\n  scrollPrev?: () => void;\n  scrollReset?: () => void;\n  scrollToView?: (n: number) => void;\n};\n\nexport interface CarouselProps {\n  /**\n   * Provide the contents of the Carousel.\n   */\n  children: ReactNode;\n  /**\n   * Provide an optional class to be applied to the containing node.\n   */\n  className?: string;\n  /**\n   * Disables the ability of the Carousel to scroll\n   * use a keyboard's left and right arrow keys.\n   */\n  disableArrowScroll?: boolean;\n  /**\n   * Enables the edges of the component to have faded styling.\n   *\n   * Pass a single string (`$color`) to specify the same color for left and right.\n   *\n   * Or pass an object (`{ left: $color1, right: $color2 }`) to specify different colors.\n   */\n  fadedEdgeColor?: string | { left: string; right: string };\n  /**\n   * An optional callback function that returns `true`\n   * when the carousel has enough content to be scrollable,\n   * and `false` when there is not enough content.\n   */\n  onChangeIsScrollable?: (isScrollable: boolean) => void;\n  /**\n   * An optional callback function that returns the scroll position as\n   * a value between 0 and 1.\n   */\n  onScroll?: (scrollPercent: number) => void;\n  /**\n   * Additional props passed to the component.\n   */\n  [key: string]: any;\n\n  /**\n   * enable scroll mode when only scroll functionality is required, more than one items will be visible at a time\n   * when isScrollMode is false, component behaves like a carousal and on item will be active at a time\n   * and other items will be hidden and inactive.\n   */\n  isScrollMode?: boolean;\n  /**\n   *This overrides the default behavior of resetting scrollLeft to 0 on resize.\n   */\n  disableResetOnResize?: boolean;\n}\n\n// The block part of our conventional BEM class names (blockClass__E--M).\nconst blockClass = `${pkg.prefix}--carousel`;\nconst componentName = 'Carousel';\n\n// Default values for props\nconst defaults = {\n  disableArrowScroll: false,\n  onScroll: () => {},\n  onChangeIsScrollable: () => {},\n};\n\n/**\n * The Carousel acts as a scaffold for other Onboarding content.\n *\n * This component is not intended for general use.\n *\n * Expected scrolling behavior.\n * 1. Scroll the maximum number of visible items at a time.\n * 2. The left-most item should always be left-aligned in the viewport.\n *\n * Exception.\n * 1. After scrolling to the last (right-most) item,\n *      if some of its content remains hidden,\n *      then nudge it to the right until it is right-aligned.\n * 2. From the right-aligned position, when scrolling left,\n *      the left-most item should again be left-aligned.\n */\nconst Carousel = React.forwardRef<HTMLDivElement, CarouselProps>(\n  (props, ref) => {\n    const {\n      children,\n      className,\n      disableArrowScroll = defaults.disableArrowScroll,\n      fadedEdgeColor,\n      onChangeIsScrollable = defaults.onChangeIsScrollable,\n      onScroll = defaults.onScroll,\n      isScrollMode = false,\n      disableResetOnResize = false,\n      ...rest\n    } = props;\n    const carouselRef = useRef<HTMLDivElement>(null);\n    const scrollRef = useRef<HTMLDivElement>(null);\n    const leftFadedEdgeRef = useRef<HTMLDivElement>(null);\n    const rightFadedEdgeRef = useRef<HTMLDivElement>(null);\n    // Array of refs used to reference this component's children DOM elements\n    const childElementsRef = useRef(\n      Array(React.Children.count(children)).fill(useRef(null))\n    );\n    const leftFadedEdgeColor =\n      typeof fadedEdgeColor === 'object'\n        ? fadedEdgeColor?.left\n        : fadedEdgeColor;\n    const rightFadedEdgeColor =\n      typeof fadedEdgeColor === 'object'\n        ? fadedEdgeColor?.right\n        : fadedEdgeColor;\n\n    const carbonPrefix = usePrefix();\n\n    // Trigger callbacks to report state of the carousel\n    const handleOnScroll = useCallback(() => {\n      if (!scrollRef.current) {\n        return;\n      }\n\n      // viewport's width\n      const clientWidth = scrollRef.current?.clientWidth;\n      // scroll position\n      const scrollLeft = parseInt(`${scrollRef.current?.scrollLeft}`, 10);\n      // scrollable width\n      const scrollWidth = scrollRef.current?.scrollWidth;\n\n      // The maximum scrollLeft achievable is the scrollable width - the viewport width.\n      const scrollLeftMax = scrollWidth - clientWidth;\n      // if isNaN(scrollLeft / scrollLeftMax), then set to zero\n      const scrollPercent =\n        parseFloat((scrollLeft / scrollLeftMax).toFixed(2)) || 0;\n\n      // Callback 1: Does the carousel have enough content to enable scrolling?\n      onChangeIsScrollable(scrollWidth > clientWidth);\n\n      // Callback 2: Return the percentage of current scroll, between 0 and 1.\n      onScroll(scrollPercent);\n    }, [onChangeIsScrollable, onScroll]);\n\n    // Check if an individual child element is visible in the container\n    const getElementInView = useCallback((containerRect, elementRect) => {\n      // Is the element's left greater than or equal to the containers left\n      const elementLeftIsRightOfContainerLeft =\n        elementRect.left >= containerRect.left;\n      // Is the element's right less than or equal to the containers right\n      const elementRightIsLeftOfContainerRight =\n        elementRect.right <= containerRect.right;\n\n      return (\n        elementLeftIsRightOfContainerLeft && elementRightIsLeftOfContainerRight\n      );\n    }, []);\n\n    // Get all elements that are visible in the container.\n    const getElementsInView = useCallback(() => {\n      const containerRect = scrollRef?.current?.getBoundingClientRect();\n      const inViewElements = childElementsRef.current.filter((el) =>\n        getElementInView(containerRect, el.getBoundingClientRect())\n      );\n      return inViewElements;\n    }, [getElementInView]);\n\n    // Return container's and children's rect data\n    const getContainerAndChildRectData = useCallback(() => {\n      // Get the rect of the container\n      const containerRect = scrollRef?.current?.getBoundingClientRect();\n      // Get all child elements that are in view of the container, and return their bounding rects.\n      const elementRectsInView = getElementsInView().map((el) =>\n        el.getBoundingClientRect()\n      );\n\n      // What is the overall width of the visible elements in the container\n      // Note: may end up being 0 if the container's width is less than the child's width\n      const visibleWidth = elementRectsInView.reduce(\n        (accumulator, currentValue) => accumulator + currentValue.width,\n        0\n      );\n\n      return { containerRect, elementRectsInView, visibleWidth };\n    }, [getElementsInView]);\n\n    const handleScrollNext = useCallback(() => {\n      if (!scrollRef.current) {\n        return;\n      }\n      const { containerRect, visibleWidth } = getContainerAndChildRectData();\n      // Set the scrollValue to the visibleWidth, but if the visibleWidth value is 0, set it to the container's width\n      const scrollValue =\n        visibleWidth > 0 ? visibleWidth : containerRect?.width;\n      // Increment the scrollLeft of the container\n      scrollRef.current.scrollLeft += scrollValue;\n    }, [getContainerAndChildRectData]);\n\n    const handleScrollPrev = useCallback(() => {\n      if (!scrollRef.current) {\n        return;\n      }\n      const { containerRect, elementRectsInView, visibleWidth } =\n        getContainerAndChildRectData();\n      // Set the scrollValue to the visibleWidth minus the first child's left value,\n      // but if the visibleWidth value is 0, set it to the container's width plus the container's left value\n      const scrollValue =\n        visibleWidth > 0\n          ? visibleWidth - elementRectsInView[0].left\n          : (containerRect?.width ?? 0) + (containerRect?.left ?? 0);\n\n      // Decrement the scrollLeft of the container\n      scrollRef.current.scrollLeft -= scrollValue;\n    }, [getContainerAndChildRectData]);\n\n    const handleScrollReset = useCallback(() => {\n      if (!scrollRef.current) {\n        return;\n      }\n      // This doesn't trigger \"scrollend\"...\n      scrollRef.current.scrollLeft = 0;\n      // ...so trigger a callback manually.\n      handleOnScroll();\n    }, [handleOnScroll]);\n\n    const handleScrollToView = useCallback((itemNumber) => {\n      updateAriaHiddenTabIndex(itemNumber);\n      childElementsRef.current[itemNumber]?.scrollIntoView();\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    const getFocusableElements = (container) => {\n      const notQuery = `:not(.${carbonPrefix}--visually-hidden,.${carbonPrefix}--btn--disabled,[aria-hidden=\"true\"],[disabled])`;\n      // Queries to include element types button, input, select, textarea\n      const queryButton = `button${notQuery}`;\n      const queryInput = `input${notQuery}`;\n      const querySelect = `select${notQuery}`;\n      const queryTextarea = `textarea${notQuery}`;\n      const queryLink = `[href]${notQuery}`;\n      const queryAnchor = `a${notQuery}`;\n      const queryTabIndex = `[tabindex=\"0\"]${notQuery}`;\n      // Final query\n      const query = `${queryButton},${queryLink},${queryAnchor},${queryInput},${querySelect},${queryTextarea},${queryTabIndex}`;\n      return container?.querySelectorAll(`${query}`) ?? [];\n    };\n\n    const updateAriaHiddenTabIndex = (itemNumber: number) => {\n      //aria-hidden need to updated based on the active item, otherwise screen reader will reset to first item while\n      //interact with element via Control + Option + Down Arrow\n      // aria-hidden is set to true to inactive carousal items\n      // tab-index is set to -1 for all inputs in in active elements\n\n      !isScrollMode &&\n        childElementsRef.current?.forEach((item, idx) => {\n          const isActive = idx === itemNumber;\n          // Set aria-hidden based on active state\n          item?.setAttribute('aria-hidden', String(!isActive));\n\n          // Update tabIndex for all focusable elements within the item\n          const focusableElements = getFocusableElements(item);\n          focusableElements.forEach((el) => {\n            el.tabIndex = isActive ? 0 : -1;\n          });\n        });\n    };\n\n    // Trigger a callback after first render (and applied CSS).\n    useEffect(() => {\n      // Normally, we can trigger a callback \"immediately after first\n      // render\", because we will be doing more \"logical\" work (update\n      // a state, show / hide a feature, etc.), and the final, applied\n      // CSS can \"catch up\" asynchronously without breaking anything.\n      setTimeout(() => {\n        // But, because we are making calculations based on the final,\n        // applied CSS, we must wait for one more \"tick\".\n\n        updateAriaHiddenTabIndex(0);\n        handleOnScroll();\n      }, 0);\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n\n    // On window.resize, reset carousel to zero.\n    useEffect(() => {\n      const handleWindowResize = () => {\n        if (!scrollRef.current) {\n          return;\n        }\n        if (!disableResetOnResize) {\n          scrollRef.current.scrollLeft = 0;\n          handleOnScroll();\n        }\n      };\n\n      window.addEventListener('resize', handleWindowResize);\n      return () => window.removeEventListener('resize', handleWindowResize);\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [handleOnScroll]);\n\n    // On scrollRef.scrollend, trigger a callback.\n    useEffect(() => {\n      const handleScrollend = () => {\n        handleOnScroll();\n      };\n\n      const scrollDiv = scrollRef.current;\n      scrollDiv?.addEventListener('scrollend', handleScrollend);\n      return () => scrollDiv?.removeEventListener('scrollend', handleScrollend);\n    }, [handleOnScroll]);\n\n    // Disable wheel scrolling\n    useEffect(() => {\n      function handleWheel(event) {\n        // update the scroll position\n        if (event.shiftKey) {\n          event.stopPropagation();\n          event.preventDefault();\n          event.cancelBubble = false;\n        }\n      }\n      const scrollDiv = scrollRef.current;\n      if (scrollDiv) {\n        scrollDiv.addEventListener('wheel', handleWheel, {\n          passive: false,\n        });\n        return () => {\n          scrollDiv.removeEventListener('wheel', handleWheel);\n        };\n      }\n    }, []);\n\n    // Enable arrow scrolling from within the carousel\n    useEffect(() => {\n      function handleKeydown(event) {\n        const { key } = event;\n\n        if (\n          (key === 'ArrowLeft' || key === 'ArrowRight') &&\n          disableArrowScroll\n        ) {\n          event.stopPropagation();\n          event.preventDefault();\n          event.cancelBubble = false;\n        }\n      }\n\n      const carouselDiv = carouselRef.current;\n      if (carouselDiv) {\n        carouselDiv.addEventListener('keydown', handleKeydown);\n        return () => carouselDiv.removeEventListener('keydown', handleKeydown);\n      }\n    }, [disableArrowScroll]);\n\n    // Enable external function calls\n    useImperativeHandle(\n      ref as RefObject<Handle>,\n      () => ({\n        scrollNext() {\n          handleScrollNext();\n        },\n        scrollPrev() {\n          handleScrollPrev();\n        },\n        scrollReset() {\n          handleScrollReset();\n        },\n        scrollToView(itemNumber) {\n          handleScrollToView(itemNumber);\n        },\n      }),\n      [\n        handleScrollNext,\n        handleScrollPrev,\n        handleScrollReset,\n        handleScrollToView,\n      ]\n    );\n\n    useIsomorphicEffect(() => {\n      if (leftFadedEdgeRef?.current && leftFadedEdgeRef.current.style) {\n        leftFadedEdgeRef.current.style.background = `linear-gradient(90deg, ${leftFadedEdgeColor}, transparent)`;\n      }\n    }, [leftFadedEdgeRef, leftFadedEdgeColor]);\n\n    useIsomorphicEffect(() => {\n      if (rightFadedEdgeRef?.current && rightFadedEdgeRef.current.style) {\n        rightFadedEdgeRef.current.style.background = `linear-gradient(270deg, ${rightFadedEdgeColor}, transparent)`;\n      }\n    }, [rightFadedEdgeRef, rightFadedEdgeColor]);\n\n    return (\n      <div\n        {...rest}\n        tabIndex={-1}\n        className={cx(blockClass, className)}\n        ref={carouselRef}\n        {...getDevtoolsProps(componentName)}\n      >\n        <div className={cx(`${blockClass}__elements-container`)}>\n          <div className={`${blockClass}__elements`} ref={scrollRef}>\n            {React.Children.map(children, (child, index) => {\n              return (\n                <CarouselItem\n                  key={index}\n                  ref={(element) => {\n                    childElementsRef.current[index] = element;\n                  }}\n                >\n                  {child}\n                </CarouselItem>\n              );\n            })}\n          </div>\n\n          {leftFadedEdgeColor && (\n            <div\n              ref={leftFadedEdgeRef}\n              className={`${blockClass}__elements-container--scrolled`}\n            ></div>\n          )}\n\n          {rightFadedEdgeColor && (\n            <div\n              ref={rightFadedEdgeRef}\n              className={`${blockClass}__elements-container--scroll-max`}\n            ></div>\n          )}\n        </div>\n      </div>\n    );\n  }\n);\n\nCarousel.displayName = componentName;\n\n// The types and DocGen commentary for the component props,\n// in alphabetical order (for consistency).\n// See https://www.npmjs.com/package/prop-types#usage.\nCarousel.propTypes = {\n  /**\n   * Provide the contents of the Carousel.\n   */\n  children: PropTypes.node.isRequired,\n  /**\n   * Provide an optional class to be applied to the containing node.\n   */\n  className: PropTypes.string,\n  /**\n   * Disables the ability of the Carousel to scroll\n   * use a keyboard's left and right arrow keys.\n   */\n  disableArrowScroll: PropTypes.bool,\n  /**\n   * Enables the edges of the component to have faded styling.\n   *\n   * Pass a single string (`$color`) to specify the same color for left and right.\n   *\n   * Or pass an object (`{ left: $color1, right: $color2 }`) to specify different colors.\n   */\n  /**@ts-ignore*/\n  fadedEdgeColor: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.shape({ left: PropTypes.string, right: PropTypes.string }),\n  ]),\n  /**\n   * enable scroll mode when only scroll functionality is required, more than one items will be visible at a time\n   * when isScrollMode is false, component behaves like a carousal and on item will be active at a time\n   * and other items will be hidden and inactive.\n   */\n  isScrollMode: PropTypes.bool,\n  /**\n   * An optional callback function that returns `true`\n   * when the carousel has enough content to be scrollable,\n   * and `false` when there is not enough content.\n   */\n  onChangeIsScrollable: PropTypes.func,\n  /**\n   * An optional callback function that returns the scroll position as\n   * a value between 0 and 1.\n   */\n  onScroll: PropTypes.func,\n};\n\nexport { Carousel };\n"],"names":["blockClass","pkg","componentName","CarouselItem","React","children","className","rest","ref","cx","getDevtoolsProps","PropTypes","defaults","Carousel","props","disableArrowScroll","fadedEdgeColor","onChangeIsScrollable","onScroll","isScrollMode","disableResetOnResize","carouselRef","useRef","scrollRef","leftFadedEdgeRef","rightFadedEdgeRef","childElementsRef","leftFadedEdgeColor","rightFadedEdgeColor","carbonPrefix","usePrefix","handleOnScroll","useCallback","clientWidth","scrollLeft","scrollWidth","scrollLeftMax","scrollPercent","getElementInView","containerRect","elementRect","elementLeftIsRightOfContainerLeft","elementRightIsLeftOfContainerRight","getElementsInView","el","getContainerAndChildRectData","elementRectsInView","visibleWidth","accumulator","currentValue","handleScrollNext","scrollValue","handleScrollPrev","handleScrollReset","handleScrollToView","itemNumber","updateAriaHiddenTabIndex","getFocusableElements","container","notQuery","queryButton","queryInput","querySelect","queryTextarea","queryLink","queryAnchor","queryTabIndex","query","item","idx","isActive","useEffect","handleWindowResize","handleScrollend","scrollDiv","handleWheel","event","handleKeydown","key","carouselDiv","useImperativeHandle","useIsomorphicEffect","child","index","element"],"mappings":"wKAgCA,MAAMA,EAAa,GAAGC,EAAI,MAAM,mBAC1BC,EAAgB,eAKhBC,EAAeC,EAAM,WACzB,CAAC,CAAE,SAAAC,EAAU,UAAAC,EAAW,GAAGC,CAAA,EAAQC,IAE/BJ,EAAA,cAAC,MAAA,CACE,GAAGG,EACJ,UAAWE,EAAGT,EAAYM,CAAS,EAClC,GAAGI,EAAiBR,CAAa,EAClC,IAAAM,CAAA,EAECH,CAAA,CAIT,EAEAF,EAAa,YAAcD,EAI3BC,EAAa,UAAY,CAIvB,SAAUQ,EAAU,KAAK,WAKzB,UAAWA,EAAU,MACvB,mYCeA,MAAMX,EAAa,GAAGC,EAAI,MAAM,aAC1BC,EAAgB,WAGhBU,EAAW,CACf,mBAAoB,GACpB,SAAU,IAAM,CAAC,EACjB,qBAAsB,IAAM,CAAC,CAC/B,EAkBMC,EAAWT,EAAM,WACrB,CAACU,EAAON,IAAQ,CACd,KAAM,CACJ,SAAAH,EACA,UAAAC,EACA,mBAAAS,EAAqBH,EAAS,mBAC9B,eAAAI,EACA,qBAAAC,EAAuBL,EAAS,qBAChC,SAAAM,EAAWN,EAAS,SACpB,aAAAO,EAAe,GACf,qBAAAC,EAAuB,GACvB,GAAGb,CAAA,EACDO,EACEO,EAAcC,EAAAA,OAAuB,IAAI,EACzCC,EAAYD,EAAAA,OAAuB,IAAI,EACvCE,EAAmBF,EAAAA,OAAuB,IAAI,EAC9CG,EAAoBH,EAAAA,OAAuB,IAAI,EAE/CI,EAAmBJ,EAAAA,OACvB,MAAMlB,EAAM,SAAS,MAAMC,CAAQ,CAAC,EAAE,KAAKiB,EAAAA,OAAO,IAAI,CAAC,CAAA,EAEnDK,EACJ,OAAOX,GAAmB,SACtBA,GAAgB,KAChBA,EACAY,EACJ,OAAOZ,GAAmB,SACtBA,GAAgB,MAChBA,EAEAa,EAAeC,EAAA,EAGfC,EAAiBC,EAAAA,YAAY,IAAM,CACvC,GAAI,CAACT,EAAU,QACb,OAIF,MAAMU,EAAcV,EAAU,SAAS,YAEjCW,EAAa,SAAS,GAAGX,EAAU,SAAS,UAAU,GAAI,EAAE,EAE5DY,EAAcZ,EAAU,SAAS,YAGjCa,EAAgBD,EAAcF,EAE9BI,EACJ,YAAYH,EAAaE,GAAe,QAAQ,CAAC,CAAC,GAAK,EAGzDnB,EAAqBkB,EAAcF,CAAW,EAG9Cf,EAASmB,CAAa,CACxB,EAAG,CAACpB,EAAsBC,CAAQ,CAAC,EAG7BoB,EAAmBN,EAAAA,YAAY,CAACO,EAAeC,IAAgB,CAEnE,MAAMC,EACJD,EAAY,MAAQD,EAAc,KAE9BG,EACJF,EAAY,OAASD,EAAc,MAErC,OACEE,GAAqCC,CAEzC,EAAG,CAAA,CAAE,EAGCC,EAAoBX,EAAAA,YAAY,IAAM,CAC1C,MAAMO,EAAgBhB,GAAW,SAAS,sBAAA,EAI1C,OAHuBG,EAAiB,QAAQ,OAAQkB,GACtDN,EAAiBC,EAAeK,EAAG,uBAAuB,CAAA,CAG9D,EAAG,CAACN,CAAgB,CAAC,EAGfO,EAA+Bb,EAAAA,YAAY,IAAM,CAErD,MAAMO,EAAgBhB,GAAW,SAAS,sBAAA,EAEpCuB,EAAqBH,IAAoB,IAAKC,GAClDA,EAAG,sBAAA,CAAsB,EAKrBG,EAAeD,EAAmB,OACtC,CAACE,EAAaC,IAAiBD,EAAcC,EAAa,MAC1D,CAAA,EAGF,MAAO,CAAE,cAAAV,EAAe,mBAAAO,EAAoB,aAAAC,CAAA,CAC9C,EAAG,CAACJ,CAAiB,CAAC,EAEhBO,EAAmBlB,EAAAA,YAAY,IAAM,CACzC,GAAI,CAACT,EAAU,QACb,OAEF,KAAM,CAAE,cAAAgB,EAAe,aAAAQ,CAAA,EAAiBF,EAAA,EAElCM,EACJJ,EAAe,EAAIA,EAAeR,GAAe,MAEnDhB,EAAU,QAAQ,YAAc4B,CAClC,EAAG,CAACN,CAA4B,CAAC,EAE3BO,EAAmBpB,EAAAA,YAAY,IAAM,CACzC,GAAI,CAACT,EAAU,QACb,OAEF,KAAM,CAAE,cAAAgB,EAAe,mBAAAO,EAAoB,aAAAC,CAAA,EACzCF,EAAA,EAGIM,EACJJ,EAAe,EACXA,EAAeD,EAAmB,CAAC,EAAE,MACpCP,GAAe,OAAS,IAAMA,GAAe,MAAQ,GAG5DhB,EAAU,QAAQ,YAAc4B,CAClC,EAAG,CAACN,CAA4B,CAAC,EAE3BQ,EAAoBrB,EAAAA,YAAY,IAAM,CACrCT,EAAU,UAIfA,EAAU,QAAQ,WAAa,EAE/BQ,EAAA,EACF,EAAG,CAACA,CAAc,CAAC,EAEbuB,EAAqBtB,cAAauB,GAAe,CACrDC,EAAyBD,CAAU,EACnC7B,EAAiB,QAAQ6B,CAAU,GAAG,eAAA,CAExC,EAAG,CAAA,CAAE,EAECE,EAAwBC,GAAc,CAC1C,MAAMC,EAAW,SAAS9B,CAAY,sBAAsBA,CAAY,mDAElE+B,EAAc,SAASD,CAAQ,GAC/BE,EAAa,QAAQF,CAAQ,GAC7BG,EAAc,SAASH,CAAQ,GAC/BI,EAAgB,WAAWJ,CAAQ,GACnCK,EAAY,SAASL,CAAQ,GAC7BM,EAAc,IAAIN,CAAQ,GAC1BO,EAAgB,iBAAiBP,CAAQ,GAEzCQ,EAAQ,GAAGP,CAAW,IAAII,CAAS,IAAIC,CAAW,IAAIJ,CAAU,IAAIC,CAAW,IAAIC,CAAa,IAAIG,CAAa,GACvH,OAAOR,GAAW,iBAAiB,GAAGS,CAAK,EAAE,GAAK,CAAA,CACpD,EAEMX,EAA4BD,GAAuB,CAMvD,CAACpC,GACCO,EAAiB,SAAS,QAAQ,CAAC0C,EAAMC,IAAQ,CAC/C,MAAMC,EAAWD,IAAQd,EAEzBa,GAAM,aAAa,cAAe,OAAO,CAACE,CAAQ,CAAC,EAGzBb,EAAqBW,CAAI,EACjC,QAASxB,GAAO,CAChCA,EAAG,SAAW0B,EAAW,EAAI,EAC/B,CAAC,CACH,CAAC,CACL,EAGAC,OAAAA,EAAAA,UAAU,IAAM,CAKd,WAAW,IAAM,CAIff,EAAyB,CAAC,EAC1BzB,EAAA,CACF,EAAG,CAAC,CAEN,EAAG,CAAA,CAAE,EAGLwC,EAAAA,UAAU,IAAM,CACd,MAAMC,EAAqB,IAAM,CAC1BjD,EAAU,UAGVH,IACHG,EAAU,QAAQ,WAAa,EAC/BQ,EAAA,GAEJ,EAEA,cAAO,iBAAiB,SAAUyC,CAAkB,EAC7C,IAAM,OAAO,oBAAoB,SAAUA,CAAkB,CAEtE,EAAG,CAACzC,CAAc,CAAC,EAGnBwC,EAAAA,UAAU,IAAM,CACd,MAAME,EAAkB,IAAM,CAC5B1C,EAAA,CACF,EAEM2C,EAAYnD,EAAU,QAC5B,OAAAmD,GAAW,iBAAiB,YAAaD,CAAe,EACjD,IAAMC,GAAW,oBAAoB,YAAaD,CAAe,CAC1E,EAAG,CAAC1C,CAAc,CAAC,EAGnBwC,EAAAA,UAAU,IAAM,CACd,SAASI,EAAYC,EAAO,CAEtBA,EAAM,WACRA,EAAM,gBAAA,EACNA,EAAM,eAAA,EACNA,EAAM,aAAe,GAEzB,CACA,MAAMF,EAAYnD,EAAU,QAC5B,GAAImD,EACF,OAAAA,EAAU,iBAAiB,QAASC,EAAa,CAC/C,QAAS,EAAA,CACV,EACM,IAAM,CACXD,EAAU,oBAAoB,QAASC,CAAW,CACpD,CAEJ,EAAG,CAAA,CAAE,EAGLJ,EAAAA,UAAU,IAAM,CACd,SAASM,EAAcD,EAAO,CAC5B,KAAM,CAAE,IAAAE,GAAQF,GAGbE,IAAQ,aAAeA,IAAQ,eAChC/D,IAEA6D,EAAM,gBAAA,EACNA,EAAM,eAAA,EACNA,EAAM,aAAe,GAEzB,CAEA,MAAMG,EAAc1D,EAAY,QAChC,GAAI0D,EACF,OAAAA,EAAY,iBAAiB,UAAWF,CAAa,EAC9C,IAAME,EAAY,oBAAoB,UAAWF,CAAa,CAEzE,EAAG,CAAC9D,CAAkB,CAAC,EAGvBiE,EAAAA,oBACExE,EACA,KAAO,CACL,YAAa,CACX0C,EAAA,CACF,EACA,YAAa,CACXE,EAAA,CACF,EACA,aAAc,CACZC,EAAA,CACF,EACA,aAAaE,EAAY,CACvBD,EAAmBC,CAAU,CAC/B,CAAA,GAEF,CACEL,EACAE,EACAC,EACAC,CAAA,CACF,EAGF2B,EAAoB,IAAM,CACpBzD,GAAkB,SAAWA,EAAiB,QAAQ,QACxDA,EAAiB,QAAQ,MAAM,WAAa,0BAA0BG,CAAkB,iBAE5F,EAAG,CAACH,EAAkBG,CAAkB,CAAC,EAEzCsD,EAAoB,IAAM,CACpBxD,GAAmB,SAAWA,EAAkB,QAAQ,QAC1DA,EAAkB,QAAQ,MAAM,WAAa,2BAA2BG,CAAmB,iBAE/F,EAAG,CAACH,EAAmBG,CAAmB,CAAC,EAGzCxB,EAAA,cAAC,MAAA,CACE,GAAGG,EACJ,SAAU,GACV,UAAWE,EAAGT,EAAYM,CAAS,EACnC,IAAKe,EACJ,GAAGX,EAAiBR,CAAa,CAAA,EAElCE,EAAA,cAAC,OAAI,UAAWK,EAAG,GAAGT,CAAU,sBAAsB,CAAA,EACpDI,EAAA,cAAC,MAAA,CAAI,UAAW,GAAGJ,CAAU,aAAc,IAAKuB,CAAA,EAC7CnB,EAAM,SAAS,IAAIC,EAAU,CAAC6E,EAAOC,IAElC/E,EAAA,cAACD,EAAA,CACC,IAAKgF,EACL,IAAMC,GAAY,CAChB1D,EAAiB,QAAQyD,CAAK,EAAIC,CACpC,CAAA,EAECF,CAAA,CAGN,CACH,EAECvD,GACCvB,EAAA,cAAC,MAAA,CACC,IAAKoB,EACL,UAAW,GAAGxB,CAAU,gCAAA,CAAA,EAI3B4B,GACCxB,EAAA,cAAC,MAAA,CACC,IAAKqB,EACL,UAAW,GAAGzB,CAAU,kCAAA,CAAA,CAG9B,CAAA,CAGN,CACF,EAEAa,EAAS,YAAcX,EAKvBW,EAAS,UAAY,CAInB,SAAUF,EAAU,KAAK,WAIzB,UAAWA,EAAU,OAKrB,mBAAoBA,EAAU,KAS9B,eAAgBA,EAAU,UAAU,CAClCA,EAAU,OACVA,EAAU,MAAM,CAAE,KAAMA,EAAU,OAAQ,MAAOA,EAAU,MAAA,CAAQ,CAAA,CACpE,EAMD,aAAcA,EAAU,KAMxB,qBAAsBA,EAAU,KAKhC,SAAUA,EAAU,IACtB;;;;;;;;;;;;;;;;;"}