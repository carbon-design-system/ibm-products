{"version":3,"file":"props-helper-CYOz70En.js","sources":["../../src/global/js/utils/props-helper.js"],"sourcesContent":["//\n// Copyright IBM Corp. 2020, 2025\n//\n// This source code is licensed under the Apache-2.0 license found in the\n// LICENSE file in the root directory of this source tree.\n//\nimport pconsole from './pconsole';\n\n// helper functions for component props\n\n/**\n * Prepare a set of props, or prop types or default props, merging values\n * from one or more sets and optionally blocking keys which should not be\n * passed. Returns the prepared set of props. Does not modify any of the\n * objects passed.\n *\n * @param {{} | '' | ['']} values One or more sets of keys and values to be\n * merged, or names of keys to be blocked. Each parameter that is an object is\n * treated as keys and values to be merged, and each parameter that is a string\n * or an array of strings is treated as keys to be blocked.\n *\n * Examples:\n *   const props = { a: 3, c: 4, d: 5 };\n *\n *   * prepareProps(props) -> { a: 3, c: 4, d: 5 }\n *   * prepareProps(props, 'c') -> { a: 3, d: 5 }\n *   * prepareProps(props, ['a', 'c', 'e']) -> { d: 5 }\n *\n *   * prepareProps({ a: 1, b: 2 }, props) -> { a: 3, b: 2, c: 4, d: 5 }\n *   * prepareProps({ a: 1, b: 2 }, props, ['a', 'c']) -> { b: 2, d: 5 }\n *\n *   * prepareProps(props, { c: 6 }) -> { a: 3, c: 6, d: 5 }\n *   * prepareProps(props, 'a', { c: 6 }) -> { c: 6, d: 5 }\n */\nexport const prepareProps = (...values) => {\n  // Convert any string or array arg into an object with nulls as values\n  const toNulls = (arg) =>\n    typeof arg === 'string'\n      ? { [arg]: null }\n      : Array.isArray(arg)\n        ? Object.fromEntries(arg.map((key) => [key, null]))\n        : arg;\n\n  // Merge all the args from left to right\n  const merged = Object.assign({}, ...values.map(toNulls));\n\n  // Now strip any keys whose final value is null\n  return Object.entries(merged).reduce((result, [key, value]) => {\n    if (value !== null) {\n      result[key] = value;\n    }\n    return result;\n  }, {});\n};\n\n// Determine whether a named prop in a set of props has been given a value.\n// null and undefined do not count as values, but anything else does. If the\n// prop is 'children', then an array of null/undefined also does not count as\n// a value, but anything else does.\nconst propHasValue = (props, propName) => {\n  let result = props[propName] !== null && props[propName] !== undefined;\n\n  if (result && propName === 'children' && Array.isArray(props[propName])) {\n    result = false;\n    for (let i = 0; !result && i < props[propName].length; i++) {\n      result = props[propName][i] !== null && props[propName][i] !== undefined;\n    }\n  }\n\n  return result;\n};\n\n/**\n * A prop-types type checker that marks a prop as deprecated.\n * @param {} validator The prop-types validator for the prop as it should be\n * used if it weren't deprecated. If this validator produces type checking\n * errors they will be reported as usual.\n * @param {*} additionalInfo One or more sentences to be appended to the\n * deprecation message to explain why the prop is deprecated and/or what should\n * be used instead.\n * @returns Any type checking error reported by the validator, or null.\n */\nexport const deprecateProp =\n  (validator, additionalInfo) =>\n  (props, propName, comp, loc, propFullName, secret) => {\n    if (propHasValue(props, propName)) {\n      pconsole.warn(\n        `The ${loc} \\`${\n          propFullName || propName\n        }\\` of \\`${comp}\\` has been deprecated and will soon be removed. ${additionalInfo}`\n      );\n    }\n    return validator(props, propName, comp, loc, propFullName, secret);\n  };\n\n/**\n * A function that returns a storybook argTypes object configured to remove deprecated\n * props from the storybook controls\n */\nexport const getDeprecatedArgTypes = (deprecatedProps) => {\n  const keys = Object.keys(deprecatedProps);\n\n  return keys.reduce(\n    (acc, cur) => ((acc[cur] = { table: { disable: true } }), acc),\n    {}\n  );\n};\n\n/**\n * A prop-types validation function that takes an array of type checkers and\n * requires prop values to satisfy all of the type checkers. This can be useful\n * to combine custom validation functions with regular prop types, or for\n * combining inherited prop-types from another component with tighter\n * requirements.\n *\n * Examples:\n *\n * MyComponent.propTypes = {\n *\n *   foo: allPropTypes([\n *     customValidationFunction,\n *     PropTypes.arrayOf(\n *       PropTypes.shape({\n *         text: PropType.string\n *       })\n *     )\n *   ]),\n *\n *   kind: allPropTypes([\n *     Button.propTypes.kind,\n *     PropTypes.oneOf(['primary', 'secondary'])\n *   ]),\n *\n * }\n */\nexport const allPropTypes = pconsole.shimIfProduction((arrayOfTypeCheckers) => {\n  if (!Array.isArray(arrayOfTypeCheckers)) {\n    pconsole.error(\n      'Warning: Invalid argument supplied to allPropTypes, expected an instance of array.'\n    );\n    return pconsole.noop;\n  }\n\n  for (let i = 0; i < arrayOfTypeCheckers.length; i++) {\n    if (typeof arrayOfTypeCheckers[i] !== 'function') {\n      pconsole.error(\n        `Invalid argument supplied to allPropTypes. Expected an array of check functions, but received ${arrayOfTypeCheckers[i]} at index ${i}.`\n      );\n      return pconsole.noop;\n    }\n  }\n\n  const checkType = (...args) => {\n    let error = null;\n    arrayOfTypeCheckers.some((checker) => (error = checker(...args)));\n    return error;\n  };\n\n  checkType.isRequired = (props, propName, comp, loc, propFullName, secret) => {\n    const prop = propFullName || propName;\n    return props[prop] == null\n      ? new Error(\n          `The ${loc} \\`${prop}\\` is marked as required in \\`${\n            comp || '<<anonymous>>'\n          }\\`, but its value is \\`${\n            props[prop] === null ? 'null' : 'undefined'\n          }\\`.`\n        )\n      : checkType(props, prop, comp, loc, propFullName, secret);\n  };\n\n  return checkType;\n});\n"],"names":["prepareProps","values","toNulls","arg","key","merged","result","value","propHasValue","props","propName","i","deprecateProp","validator","additionalInfo","comp","loc","propFullName","secret","getDeprecatedArgTypes","deprecatedProps","acc","cur","allPropTypes","pconsole","arrayOfTypeCheckers","checkType","args","error","checker","prop"],"mappings":"yCAkCO,MAAMA,EAAe,IAAIC,IAAW,CAEzC,MAAMC,EAAWC,GACf,OAAOA,GAAQ,SACX,CAAE,CAACA,CAAG,EAAG,MACT,MAAM,QAAQA,CAAG,EACf,OAAO,YAAYA,EAAI,IAAKC,GAAQ,CAACA,EAAK,IAAI,CAAC,CAAC,EAChDD,EAGFE,EAAS,OAAO,OAAO,CAAA,EAAI,GAAGJ,EAAO,IAAIC,CAAO,CAAC,EAGvD,OAAO,OAAO,QAAQG,CAAM,EAAE,OAAO,CAACC,EAAQ,CAACF,EAAKG,CAAK,KACnDA,IAAU,OACZD,EAAOF,CAAG,EAAIG,GAETD,GACN,CAAA,CAAE,CACP,EAMME,EAAe,CAACC,EAAOC,IAAa,CACxC,IAAIJ,EAASG,EAAMC,CAAQ,IAAM,MAAQD,EAAMC,CAAQ,IAAM,OAE7D,GAAIJ,GAAUI,IAAa,YAAc,MAAM,QAAQD,EAAMC,CAAQ,CAAC,EAAG,CACvEJ,EAAS,GACT,QAASK,EAAI,EAAG,CAACL,GAAUK,EAAIF,EAAMC,CAAQ,EAAE,OAAQC,IACrDL,EAASG,EAAMC,CAAQ,EAAEC,CAAC,IAAM,MAAQF,EAAMC,CAAQ,EAAEC,CAAC,IAAM,MAEnE,CAEA,OAAOL,CACT,EAYaM,EACX,CAACC,EAAWC,IACZ,CAACL,EAAOC,EAAUK,EAAMC,EAAKC,EAAcC,KACrCV,EAAaC,EAAOC,CAAQ,EAOzBG,EAAUJ,EAAOC,EAAUK,EAAMC,EAAKC,EAAcC,CAAM,GAOxDC,EAAyBC,GACvB,OAAO,KAAKA,CAAe,EAE5B,OACV,CAACC,EAAKC,KAAUD,EAAIC,CAAG,EAAI,CAAE,MAAO,CAAE,QAAS,EAAA,CAAK,EAAMD,GAC1D,CAAA,CAAC,EA+BQE,EAAeC,EAAS,iBAAkBC,GAAwB,CAC7E,GAAI,CAAC,MAAM,QAAQA,CAAmB,EAIpC,OAAOD,EAAS,KAGlB,QAASb,EAAI,EAAGA,EAAIc,EAAoB,OAAQd,IAC9C,GAAI,OAAOc,EAAoBd,CAAC,GAAM,WACpC,OAAAa,EAAS,MACP,iGAAiGC,EAAoBd,CAAC,CAAC,aAAaA,CAAC,GAAA,EAEhIa,EAAS,KAIpB,MAAME,EAAY,IAAIC,IAAS,CAC7B,IAAIC,EAAQ,KACZ,OAAAH,EAAoB,KAAMI,GAAaD,EAAQC,EAAQ,GAAGF,CAAI,CAAE,EACzDC,CACT,EAEA,OAAAF,EAAU,WAAa,CAACjB,EAAOC,EAAUK,EAAMC,EAAKC,EAAcC,IAAW,CAC3E,MAAMY,EAAOb,GAAgBP,EAC7B,OAAOD,EAAMqB,CAAI,GAAK,KAClB,IAAI,MACF,OAAOd,CAAG,MAAMc,CAAI,iCAClBf,GAAQ,eACV,0BACEN,EAAMqB,CAAI,IAAM,KAAO,OAAS,WAClC,KAAA,EAEFJ,EAAUjB,EAAOqB,EAAMf,EAAMC,EAAKC,EAAcC,CAAM,CAC5D,EAEOQ,CACT,CAAC"}